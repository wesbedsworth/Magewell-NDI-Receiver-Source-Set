-----------------------------------------------------
-- NDI Receiver Management Script
-- Version: 2.1 Debug
-- Purpose: Automatically configures NDI receivers to use the correct source based on IP address
-----------------------------------------------------


-----------------------------------------------------
-- Script Properties
-----------------------------------------------------
property sessionCookie : ""
property configFileName : "NDIReceiverConfig.json"
property debugMode : false -- Enable debug mode


-----------------------------------------------------
-- Main Script
-----------------------------------------------------
-- Start debugging output if debugMod is enabled
if debugMode then
	set debugResponse to display dialog "Debug mode enabled. Press OK to start execution or Cancel to abort." buttons {"Cancel", "OK"} default button "OK" with icon caution
	
	if button returned of debugResponse is "Cancel" then
		-- User canceled execution
		return -- Exit the script
	end if
	
	debugOutput("NDI Receiver Management Script starting...")
end if


-- Find jq path dynamically
debugOutput("Determining path to jq and verifying installation.")
set jqPath to findJQPath()
if jqPath is "" then
	display dialog "Could not find jq. Please install jq and try again." & return & return & "You can install jq with Homebrew:" & return & "brew install jq" buttons {"OK"} default button "OK" with icon stop
	return -- Exit the script
end if
debugOutput("Found jq installation at: " & jqPath)


-- Load configuration from file
debugOutput("Loading NDI Receiver configuration JSON file.")
set config to loadConfiguration(jqPath)
if not config's success then
	return -- Exit if config can't be loaded
end if
debugOutput("Configuration file loaded successfully.")


-- Extract configuration values
set userName to config's userName
set userPW to config's userPW
set receiverList to config's receiverList
set connectTimeout to config's connectTimeout
debugOutput("Count of receivers to process: " & (count of receiverList))


-- At the beginning of the script, after loading configuration, display warning to user prior to proceeding
display dialog "About to set channels for " & (count of receiverList) & " NDI receivers." & return & return & "This will take a few moments during which there will be no progress indication on the screen." & return & return & "Please be patient. A summary will be displayed when complete." buttons {"OK", "Cancel"} default button "OK"
if button returned of result is "Cancel" then
	return -- Exit if user cancels
end if


-- Record start time in seconds
set startTimeSeconds to do shell script "date +%s"


-- This list will accumulate summary records for each receiver
set summaryResults to {}


-- Main Loop: Process each receiver in sequence
repeat with i from 1 to count of receiverList
	set receiverIP to item i of receiverList
	
	-- Initialize a record to store the result for this receiver
	set receiverResult to {receiver:receiverIP, status:"", source:""}
	
	-- Reset session cookie for each new receiver
	set sessionCookie to ""
	
	try
		-- Debug marker BEFORE availability check
		debugOutput("STEP A: Checking receiver availability for " & receiverIP)
		set startTime to current date
		
		-- (A) Check if receiver is available (both network and API)
		set availabilityStatus to checkReceiverAvailability(receiverIP, jqPath)
		
		-- Debug marker AFTER availability check
		set endTime to current date
		set elapsedSeconds to endTime - startTime
		debugOutput("Availability check completed in " & elapsedSeconds & " seconds.")
		debugOutput("Availability result: reachable=" & availabilityStatus's reachable & ", apiAvailable=" & availabilityStatus's apiAvailable)
		
		if not availabilityStatus's reachable then
			set receiverResult's status to "Unreachable (network ping failed)"
			set receiverResult's source to "N/A"
			debugOutput("Device unreachable at " & receiverIP & ": " & availabilityStatus's message)
			error "Skipping receiver " & receiverIP & " - network unreachable"
		else if not availabilityStatus's apiAvailable then
			set receiverResult's status to "API unavailable"
			set receiverResult's source to "N/A"
			debugOutput("API unavailable for " & receiverIP & ": " & availabilityStatus's message)
			error "Skipping receiver " & receiverIP & " - API unavailable"
		end if
		
		-- Debug marker BEFORE login
		debugOutput("STEP B: Logging in to " & receiverIP & " and retrieving session cookie.")
		
		-- (B) Login to the receiver using session cookie management
		set loginResponse to loginToReceiver(receiverIP, userName, userPW, connectTimeout)
		debugOutput("Login Response for " & receiverIP & ": " & loginResponse)
		checkResponse(loginResponse, "Login failed for receiver " & receiverIP, jqPath)
		
		-- Debug marker BEFORE source retrieval
		debugOutput("STEP C: Retrieving sources from " & receiverIP)
		
		-- (C) Retrieve the list of available sources using session cookie
		set getSourcesURL to "http://" & receiverIP & "/mwapi?method=get-ndi-sources"
		set jsonResponse to runCURLWithSession(getSourcesURL, connectTimeout)
		debugOutput("NDI Sources JSON response for " & receiverIP & ": " & jsonResponse)
		checkResponse(jsonResponse, "Failed to retrieve sources for receiver " & receiverIP, jqPath)
		
		-- Debug marker BEFORE source filtering
		debugOutput("STEP D: Filtering sources for " & receiverIP)
		
		-- (D) Use jq to filter sources for the desired receiver IP
		set desiredIP to receiverIP
		set jqQuery to ".sources[] | select(.\"ndi-name\" | contains(\"" & desiredIP & "\"))"
		set targetSourceRaw to do shell script "echo " & quoted form of jsonResponse & " | " & jqPath & " '" & jqQuery & "'"
		debugOutput("Target source for " & receiverIP & " obtained via jq: " & targetSourceRaw)
		
		if targetSourceRaw is not "" then
			-- Debug marker BEFORE source extraction
			debugOutput("STEP E: Extracting NDI name for " & receiverIP)
			
			-- (E) Extract the ndi-name field using jq and remove extra quotes, then URL encode the name
			set ndiNameRaw to do shell script "echo " & quoted form of targetSourceRaw & " | " & jqPath & " '.\"ndi-name\"' | tr -d '\"'"
			debugOutput("NDI Name for " & receiverIP & ": " & ndiNameRaw)
			set encodedNdiName to urlEncode(ndiNameRaw)
			debugOutput("Encoded NDI Name for " & receiverIP & ": " & encodedNdiName)
			
			-- Debug marker BEFORE channel setting
			debugOutput("STEP F: Setting channel for " & receiverIP)
			
			-- (F) Set the receiver's channel to the found source
			set setChannelURL to "http://" & receiverIP & "/mwapi?method=set-channel&ndi-name=true&name=" & encodedNdiName
			set setChannelResponse to runCURLWithSession(setChannelURL, connectTimeout)
			debugOutput("Set Channel Response for " & receiverIP & ": " & setChannelResponse)
			checkResponse(setChannelResponse, "Set channel for receiver " & receiverIP, jqPath)
			
			set receiverResult's status to "Success"
			set receiverResult's source to ndiNameRaw
		else
			set receiverResult's status to "Fail (No valid source found)"
			set receiverResult's source to "N/A"
		end if
		
		-- Debug marker BEFORE logout
		debugOutput("STEP G: Logging out from " & receiverIP)
		
		-- (G) Logout from the receiver
		set logoutURL to "http://" & receiverIP & "/mwapi?method=logout"
		runCURLWithSession(logoutURL, connectTimeout)
		
	on error errMsg
		debugOutput("ERROR processing receiver " & receiverIP & ": " & errMsg)
	end try
	
	-- Append the result for this receiver to the summaryResults list
	set end of summaryResults to receiverResult
	debugOutput("Finished processing receiver: " & receiverIP)
end repeat


-- Calculate elapsed time
set endTimeSeconds to do shell script "date +%s"
set elapsedSeconds to (endTimeSeconds as number) - (startTimeSeconds as number)
set elapsedFormatted to my formatSeconds(elapsedSeconds)

-- Build and Display the Summary Dialog
my debugOutput("Preparing summary report")
set summaryText to "NDI Receiver Summary:" & return & return
set summaryText to summaryText & "Total time: " & elapsedFormatted & return & return

repeat with res in summaryResults
	set summaryText to summaryText & "Receiver: " & (res's receiver) & return
	set summaryText to summaryText & "Status: " & (res's status) & return
	set summaryText to summaryText & "Source set: " & (res's source) & return & return
end repeat

my debugOutput("Displaying summary dialog")
display dialog summaryText buttons {"OK"} default button "OK" with title "NDI Receiver Setup Results"

-----------------------------------------------------
-- Utility Functions
-----------------------------------------------------
-- Find jq executable path
on findJQPath()
	set possiblePaths to {"/usr/local/bin/jq", "/usr/bin/jq", "/opt/homebrew/bin/jq", "~/bin/jq"}
	
	-- First try the which command to find it in PATH
	try
		set jqPathFromEnv to do shell script "which jq"
		if jqPathFromEnv is not "" then
			-- Found jq in PATH
			debugOutput("Found jq in PATH: " & jqPathFromEnv)
			return jqPathFromEnv
		end if
	on error
		-- which command failed, jq might not be in PATH
	end try
	
	-- Check each possible location
	repeat with testPath in possiblePaths
		try
			-- Expand path if it contains tilde
			if testPath begins with "~/" then
				set homeFolder to POSIX path of (path to home folder)
				set testPath to homeFolder & text 3 thru -1 of testPath
			end if
			
			-- Test if jq exists at this path
			do shell script "[ -x " & quoted form of testPath & " ]"
			debugOutput("Found jq installation at: " & testPath)
			return testPath
		on error
			-- Not found at this path, continue checking
		end try
	end repeat
	
	-- Not found in any location
	return ""
end findJQPath


-- Load configuration from file with flexible location detection
on loadConfiguration(jqPath)
	my debugOutput("Starting configuration loading")
	set configResult to {success:false, userName:"", userPW:"", receiverList:{}, connectTimeout:4}
	set configPath to missing value
	
	-- First, try to determine if we're running in QLab
	set runningInQLab to false
	try
		tell application "QLab" to get q number
		set runningInQLab to true
		my debugOutput("Detected running in QLab")
	on error
		-- Not running in QLab or QLab isn't open
		set runningInQLab to false
		my debugOutput("Not running in QLab")
	end try
	
	-- Try to find config based on context (QLab or standalone)
	if runningInQLab then
		-- In QLab: Look for config file relative to the current workspace
		try
			-- Using temporary variables outside of tell block
			set foundConfig to false
			set tempPath to ""
			
			tell application "QLab"
				if exists front workspace then
					set qLabPath to path of front workspace
					set tempPath to qLabPath
				end if
			end tell
			
			-- Process the path outside the tell block
			if tempPath is not "" then
				my debugOutput("QLab workspace path: " & tempPath)
				-- Extract directory from the full path
				set showfileFolder to do shell script "dirname " & quoted form of tempPath
				set defaultConfigPath to showfileFolder & "/" & configFileName
				my debugOutput("Looking for config at: " & defaultConfigPath)
				
				-- Check if config exists in the showfile's directory
				set fileExists to false
				tell application "System Events"
					if exists file defaultConfigPath then
						set fileExists to true
					end if
				end tell
				
				if fileExists then
					set configPath to defaultConfigPath
					my debugOutput("Found config file in QLab workspace folder: " & configPath)
				else
					my debugOutput("Config file not found in QLab workspace folder")
				end if
			else
				my debugOutput("No front workspace in QLab")
			end if
		on error qlabErr
			my debugOutput("Error checking QLab workspace location: " & qlabErr)
		end try
	else
		-- Standalone: Look for config in the script's directory
		try
			set scriptPath to path to me
			my debugOutput("Script path: " & scriptPath)
			set scriptFolder to container of scriptPath as text
			set defaultConfigPath to scriptFolder & configFileName
			my debugOutput("Looking for config at: " & defaultConfigPath)
			
			set fileExists to false
			tell application "System Events"
				if exists file defaultConfigPath then
					set fileExists to true
				end if
			end tell
			
			if fileExists then
				set configPath to defaultConfigPath
				my debugOutput("Found config file in script folder: " & configPath)
			else
				my debugOutput("Config file not found in script folder")
			end if
		on error scriptErr
			my debugOutput("Error checking script location: " & scriptErr)
		end try
	end if
	
	-- If still not found, try Documents folder as a fallback
	if configPath is missing value then
		set docsConfigPath to (path to documents folder as text) & configFileName
		my debugOutput("Looking for config in Documents folder: " & docsConfigPath)
		
		set fileExists to false
		tell application "System Events"
			if exists file docsConfigPath then
				set fileExists to true
			end if
		end tell
		
		if fileExists then
			set configPath to docsConfigPath
			my debugOutput("Found config file in Documents folder: " & configPath)
		else
			my debugOutput("Config file not found in Documents folder")
		end if
	end if
	
	-- If still not found, prompt user to select it
	if configPath is missing value then
		my debugOutput("Config file not found in any standard location, prompting user")
		try
			set userPrompt to "Configuration file (" & configFileName & ") not found." & return & return & "Please select the configuration file:"
			set defaultLocation to path to documents folder
			set selectedFile to choose file with prompt userPrompt default location defaultLocation
			set configPath to selectedFile as text
			my debugOutput("User selected config file: " & configPath)
		on error selectErr
			my debugOutput("User canceled file selection or error occurred: " & selectErr)
			display dialog "No configuration file selected. Cannot continue." buttons {"OK"} default button "OK" with icon stop
			return configResult
		end try
	end if
	
	-- Now validate and parse the JSON file
	my debugOutput("Attempting to read config file: " & configPath)
	try
		set configFile to open for access configPath
		set configData to read configFile
		close access configFile
		my debugOutput("Successfully read config file, validating JSON structure")
		
		-- Validate JSON structure before extracting fields
		try
			set jqCmd to "echo " & quoted form of configData & " | " & jqPath & " ."
			my debugOutput("Validating JSON structure with command: " & jqCmd)
			do shell script jqCmd
			my debugOutput("JSON structure validation successful")
		on error jqError
			my debugOutput("JSON validation error: " & jqError)
			display dialog "The configuration file contains invalid JSON:" & return & return & jqError buttons {"OK"} default button "OK" with icon stop
			return configResult
		end try
		
		-- Extract individual fields with error handling for each
		try
			set jqCmd to "echo " & quoted form of configData & " | " & jqPath & " -r '.userName'"
			my debugOutput("Extracting userName with command: " & jqCmd)
			set configResult's userName to do shell script jqCmd
			my debugOutput("Extracted userName: " & configResult's userName)
			
			if configResult's userName is "" or configResult's userName is "null" then
				my debugOutput("ERROR: userName is missing or empty")
				error "userName is missing or empty"
			end if
		on error fieldErr
			my debugOutput("ERROR extracting userName: " & fieldErr)
			display dialog "Error in configuration file: userName field is invalid or missing." buttons {"OK"} default button "OK" with icon stop
			return configResult
		end try
		
		try
			set jqCmd to "echo " & quoted form of configData & " | " & jqPath & " -r '.userPW'"
			my debugOutput("Extracting userPW with command: " & jqCmd)
			set configResult's userPW to do shell script jqCmd
			my debugOutput("Extracted userPW: [REDACTED]") -- Don't log actual password
			
			if configResult's userPW is "" or configResult's userPW is "null" then
				my debugOutput("ERROR: userPW is missing or empty")
				error "userPW is missing or empty"
			end if
		on error fieldErr
			my debugOutput("ERROR extracting userPW: " & fieldErr)
			display dialog "Error in configuration file: userPW field is invalid or missing." buttons {"OK"} default button "OK" with icon stop
			return configResult
		end try
		
		try
			-- Verify receiverList exists and is an array
			set jqCmd to "echo " & quoted form of configData & " | " & jqPath & " '.receiverList | type'"
			my debugOutput("Checking receiverList type with command: " & jqCmd)
			set receiverListType to do shell script jqCmd
			my debugOutput("receiverList type: " & receiverListType)
			
			if receiverListType does not contain "array" then
				my debugOutput("ERROR: receiverList must be an array, found type: " & receiverListType)
				display dialog "Error in configuration file: receiverList must be an array." buttons {"OK"} default button "OK" with icon stop
				return configResult
			end if
			
			set jqCmd to "echo " & quoted form of configData & " | " & jqPath & " -r '.receiverList[]'"
			my debugOutput("Extracting receiverList with command: " & jqCmd)
			set configResult's receiverList to paragraphs of (do shell script jqCmd)
			my debugOutput("Extracted " & (count of configResult's receiverList) & " receivers: " & (configResult's receiverList as text))
			
			if (count of configResult's receiverList) is 0 or configResult's receiverList is {"null"} then
				my debugOutput("ERROR: receiverList is empty")
				display dialog "Error in configuration file: receiverList is empty." buttons {"OK"} default button "OK" with icon stop
				return configResult
			end if
		on error fieldErr
			my debugOutput("ERROR extracting receiverList: " & fieldErr)
			display dialog "Error in configuration file: receiverList field is invalid or missing." & return & return & fieldErr buttons {"OK"} default button "OK" with icon stop
			return configResult
		end try
		
		-- First check if the connectTimeout field exists at all
		set jqCmd to "echo " & quoted form of configData & " | " & jqPath & " -r 'has(\"connectTimeout\")'"
		my debugOutput("Checking if connectTimeout exists with command: " & jqCmd)
		set hasTimeout to do shell script jqCmd
		my debugOutput("connectTimeout exists: " & hasTimeout)
		
		if hasTimeout is "true" then
			-- Field exists, get its value and check its type
			set jqCmd to "echo " & quoted form of configData & " | " & jqPath & " -r '.connectTimeout | type'"
			my debugOutput("Checking connectTimeout type with command: " & jqCmd)
			set timeoutType to do shell script jqCmd
			my debugOutput("connectTimeout type: " & timeoutType)
			
			if timeoutType contains "number" then
				-- It's a number, use it directly
				set jqCmd to "echo " & quoted form of configData & " | " & jqPath & " -r '.connectTimeout'"
				my debugOutput("Extracting connectTimeout (number) with command: " & jqCmd)
				set timeoutValue to do shell script jqCmd
				set configResult's connectTimeout to timeoutValue as number
				my debugOutput("Set connectTimeout to: " & configResult's connectTimeout)
			else if timeoutType contains "string" then
				-- It's a string, try to convert to number
				set jqCmd to "echo " & quoted form of configData & " | " & jqPath & " -r '.connectTimeout'"
				my debugOutput("Extracting connectTimeout (string) with command: " & jqCmd)
				set timeoutStr to do shell script jqCmd
				my debugOutput("Got connectTimeout string: " & timeoutStr)
				try
					set configResult's connectTimeout to timeoutStr as number
					my debugOutput("Converted connectTimeout to number: " & configResult's connectTimeout)
				on error
					my debugOutput("ERROR: connectTimeout string could not be converted to number: " & timeoutStr)
					display dialog "Error in configuration file: connectTimeout must be a number, got \"" & timeoutStr & "\"" buttons {"OK"} default button "OK" with icon stop
					return configResult
				end try
			else if timeoutType contains "null" then
				-- It's explicitly null, use default
				set configResult's connectTimeout to 4
				my debugOutput("connectTimeout is null, using default: 4")
			else
				-- It's some other type (boolean, object, array)
				my debugOutput("ERROR: connectTimeout has invalid type: " & timeoutType)
				display dialog "Error in configuration file: connectTimeout must be a number, got " & timeoutType buttons {"OK"} default button "OK" with icon stop
				return configResult
			end if
		else
			-- Field doesn't exist at all, use default
			set configResult's connectTimeout to 4
			my debugOutput("connectTimeout not found in config, using default: 4")
		end if
		
		set configResult's success to true
		my debugOutput("Configuration loaded successfully from: " & configPath)
		return configResult
	on error errMsg
		my debugOutput("Failed to load configuration: " & errMsg)
		display dialog "Failed to load configuration: " & errMsg buttons {"OK"} default button "OK" with icon stop
		return configResult
	end try
end loadConfiguration


-- Check receiver availability (both network and API)
on checkReceiverAvailability(receiverIP, jqPath)
	-- Initialize all local variables at the start
	set pingSuccess to false
	set apiSuccess to false
	set errorMessage to ""
	
	-- Debug timestamp before network check
	debugOutput("Starting network ping check for " & receiverIP)
	
	-- Stage 1: Check basic network connectivity with strict timeout
	try
		-- Use a very short timeout to avoid hanging - with debugging output
		set pingCmd to "ping -c 1 -W 0.5 -t 1 " & receiverIP & " 2>&1 || echo 'Ping timeout'"
		debugOutput("Running ping command: " & pingCmd)
		
		set pingResponse to do shell script pingCmd
		
		-- Log raw response for debugging
		debugOutput("Raw ping response for " & receiverIP & ": " & pingResponse)
		
		if pingResponse contains "1 packets transmitted, 1 packets received" then
			set pingSuccess to true
			debugOutput("Network ping successful for " & receiverIP)
		else
			set errorMessage to "Network ping failed: " & pingResponse
			debugOutput("Network ping failed for " & receiverIP & ": " & pingResponse)
			-- Return early with just ping results
			return {reachable:pingSuccess, apiAvailable:apiSuccess, message:errorMessage}
		end if
	on error pingErr
		set errorMessage to "Network error: " & pingErr
		debugOutput("Network ping error for " & receiverIP & ": " & pingErr)
		-- Return early with just ping results
		return {reachable:pingSuccess, apiAvailable:apiSuccess, message:errorMessage}
	end try
	
	-- Only proceed to API check if ping was successful
	if not pingSuccess then
		return {reachable:pingSuccess, apiAvailable:apiSuccess, message:errorMessage}
	end if
	
	-- Debug timestamp before API check
	debugOutput("Starting API ping check for " & receiverIP & "...")
	
	-- Stage 2: Check API availability with strict timeout
	try
		set apiPingURL to "http://" & receiverIP & "/mwapi?method=ping"
		-- Force a very short timeout to avoid hanging
		set curlCmd to "curl --max-time 2 --connect-timeout 1 --silent " & quoted form of apiPingURL & " || echo '{\"status\":\"timeout\"}'"
		
		debugOutput("Running curl command: " & curlCmd)
		
		set apiResponse to do shell script curlCmd
		
		-- Log raw response for debugging
		debugOutput("Raw API response for " & receiverIP & ": " & apiResponse)
		
		-- Verify it's a valid response
		set isValidResponse to false
		try
			set jqCmd to "echo " & quoted form of apiResponse & " | " & jqPath & " '.status' 2>/dev/null || echo 'parse_error'"
			debugOutput("Running jq command: " & jqCmd)
			
			set statusCheck to do shell script jqCmd
			debugOutput("Status check result: " & statusCheck)
			
			if statusCheck as text is "0" then
				set isValidResponse to true
			end if
		end try
		
		if isValidResponse then
			set apiSuccess to true
			set errorMessage to "Receiver available"
			debugOutput("API ping successful for " & receiverIP)
		else
			set errorMessage to "API ping failed: Invalid response - " & apiResponse
			debugOutput("API ping failed for " & receiverIP & ": Invalid response - " & apiResponse)
		end if
	on error apiErr
		set errorMessage to "API error: " & apiErr
		debugOutput("API ping error for " & receiverIP & ": " & apiErr)
	end try
	
	debugOutput("Completed availability check for " & receiverIP)
	
	-- Create and return final result record
	return {reachable:pingSuccess, apiAvailable:apiSuccess, message:errorMessage}
end checkReceiverAvailability


-- Login to receiver and capture session cookie
on loginToReceiver(receiverIP, userName, userPW, connectTimeout)
	set loginURL to "http://" & receiverIP & "/mwapi?method=login&id=" & userName & "&pass=" & userPW
	
	-- Get the login response with headers
	set loginCmd to "curl -i --connect-timeout " & connectTimeout & " --max-time " & (connectTimeout * 2) & " --silent " & quoted form of loginURL
	debugOutput("Login command: " & loginCmd)
	set fullLoginResponse to do shell script loginCmd
	
	-- Log the complete response for debugging
	debugOutput("Full login response: " & fullLoginResponse)
	
	-- Extract the session ID from the Set-Cookie header
	try
		set cookieCmd to "echo " & quoted form of fullLoginResponse & " | grep -i 'Set-Cookie:' | awk -F'[=;]' '{print $2}'"
		set sessionID to do shell script cookieCmd
		debugOutput("Extracted session ID: " & sessionID)
		
		-- Store the cookie in the correct format
		if sessionID is not "" then
			set sessionCookie to "sid=" & sessionID
			debugOutput("Set cookie to: " & sessionCookie)
			-- Return success response since we got a session ID
			return "{\"status\": 0}"
		else
			set sessionCookie to ""
			debugOutput("No session ID found in response.")
			-- Return error if no session ID found
			return "{\"status\": -1, \"error\": \"No session ID in response\"}"
		end if
	on error cookieErr
		set sessionCookie to ""
		debugOutput("Error extracting cookie: " & cookieErr)
		-- Return error for extraction failure
		return "{\"status\": -1, \"error\": \"Failed to extract cookie: " & cookieErr & "\"}"
	end try
end loginToReceiver


-- Run curl command with session cookie
on runCURLWithSession(theURL, connectTimeout)
	if sessionCookie is "" then
		-- No cookie available, just run a simple curl command
		set curlCmd to "curl --connect-timeout " & connectTimeout & " --max-time " & (connectTimeout * 2) & " --silent " & quoted form of theURL
		debugOutput("Running curl command (no cookie): " & curlCmd)
		return do shell script curlCmd
	else
		-- Use the stored session cookie in the format "sid=SESSIONID"
		set curlCmd to "curl --connect-timeout " & connectTimeout & " --max-time " & (connectTimeout * 2) & " --silent -b " & quoted form of sessionCookie & " " & quoted form of theURL
		debugOutput("Running curl command (with cookie): " & curlCmd)
		return do shell script curlCmd
	end if
end runCURLWithSession


-- URL Encode function
on urlEncode(input)
	debugOutput("URL encoding input: " & input)
	try
		set encoded to do shell script "python3 -c 'import urllib.parse; print(urllib.parse.quote(\"" & input & "\"))'"
		debugOutput("URL encoded result: " & encoded)
		return encoded
	on error errMsg
		debugOutput("URL Encoding failed: " & errMsg)
		error "URL Encoding failed: " & errMsg
	end try
end urlEncode


-- Check API response
on checkResponse(response, errorMessage, jqPath)
	debugOutput("Checking API response: " & response)
	try
		set jqCmd to "echo " & quoted form of response & " | " & jqPath & " '.status'"
		debugOutput("Running status check: " & jqCmd)
		
		set statusValue to do shell script jqCmd
		debugOutput("Status check result: " & statusValue)
		
		if statusValue as text is not "0" then
			debugOutput("API check FAILED: " & errorMessage)
			error errorMessage & " failed. Response: " & response
		else
			debugOutput("API check SUCCESS")
		end if
	on error errMsg
		debugOutput("API check ERROR: " & errMsg)
		error errorMessage & " (jq parse error: " & errMsg & "). Full Response: " & response
	end try
end checkResponse


-- Format seconds into minutes and seconds
on formatSeconds(totalSeconds)
	set minutes to totalSeconds div 60
	set remainingSeconds to totalSeconds mod 60
	if minutes > 0 then
		return minutes & " min " & remainingSeconds & " sec"
	else
		return totalSeconds & " seconds"
	end if
end formatSeconds


-- Enhanced debug output function
on debugOutput(msg)
	-- Only log if debug mode is enabled
	if debugMode then
		set currentDate to do shell script "date '+%Y-%m-%d %H:%M:%S.%N'"
		set logMsg to "[" & currentDate & "] " & msg
		
		-- Log to the console
		log logMsg
	end if
end debugOutput
