-----------------------------------------------------
-- NDI Receiver Management Script
-- Version: 2.1 Debug
-- Purpose: Automatically configures NDI receivers to use the correct source
-----------------------------------------------------

-- Script Properties
-----------------------------------------------------
property sessionCookie : ""
property configFileName : "NDIReceiverConfig.json"
property debugMode : true -- Enable debug mode


-----------------------------------------------------
-- Main Script
-----------------------------------------------------
-- Start debugging output
if debugMode then
	display dialog "Debug mode enabled. Press OK to start execution." buttons {"OK"} default button "OK"
end if

debugOutput("Script starting")


-- Find jq path dynamically
debugOutput("Finding jq path...")
set jqPath to findJQPath()
if jqPath is "" then
	display dialog "Could not find jq. Please install jq and try again." & return & return & "You can install jq with Homebrew:" & return & "brew install jq" buttons {"OK"} default button "OK" with icon stop
	return -- Exit the script
end if
debugOutput("Found jq at: " & jqPath)


-- Load configuration from file
debugOutput("Loading configuration...")
set config to loadConfiguration(jqPath)
if not config's success then
	return -- Exit if config can't be loaded
end if
debugOutput("Configuration loaded successfully")


-- Extract configuration values
set userName to config's userName
set userPW to config's userPW
set receiverList to config's receiverList
set connectTimeout to config's connectTimeout
debugOutput("Receiver count: " & (count of receiverList))


-- At the beginning of the script, after loading configuration:
display dialog "About to process " & (count of receiverList) & " receivers." & return & return & "This will take a few moments. A summary will be displayed when complete." buttons {"OK", "Cancel"} default button "OK"
if button returned of result is "Cancel" then
	return -- Exit if user cancels
end if


-- Record start time in seconds
set startTimeSeconds to do shell script "date +%s"


-- This list will accumulate summary records for each receiver
set summaryResults to {}


-- Main Loop: Process each receiver in sequence
repeat with i from 1 to count of receiverList
	set receiverIP to item i of receiverList
	
	-- Initialize a record to store the result for this receiver
	set receiverResult to {receiver:receiverIP, status:"", source:""}
	
	-- Reset session cookie for each new receiver
	set sessionCookie to ""
	
	try
		-- Debug marker BEFORE availability check
		debugOutput("STEP A: Checking receiver availability for " & receiverIP)
		set startTime to current date
		
		-- (A) Check if receiver is available (both network and API)
		set availabilityStatus to checkReceiverAvailability(receiverIP, jqPath)
		
		-- Debug marker AFTER availability check
		set endTime to current date
		set elapsedSeconds to endTime - startTime
		debugOutput("Availability check completed in " & elapsedSeconds & " seconds")
		debugOutput("Availability result: reachable=" & availabilityStatus's reachable & ", apiAvailable=" & availabilityStatus's apiAvailable)
		
		if not availabilityStatus's reachable then
			set receiverResult's status to "Unreachable (network ping failed)"
			set receiverResult's source to "N/A"
			debugOutput("Network unreachable for " & receiverIP & ": " & availabilityStatus's message)
			error "Skipping receiver " & receiverIP & " - network unreachable"
		else if not availabilityStatus's apiAvailable then
			set receiverResult's status to "API unavailable"
			set receiverResult's source to "N/A"
			debugOutput("API unavailable for " & receiverIP & ": " & availabilityStatus's message)
			error "Skipping receiver " & receiverIP & " - API unavailable"
		end if
		
		-- Debug marker BEFORE login
		debugOutput("STEP B: Logging in to " & receiverIP)
		
		-- (B) Login to the receiver using the new session cookie management
		set loginResponse to loginToReceiver(receiverIP, userName, userPW, connectTimeout)
		debugOutput("Login Response for " & receiverIP & ": " & loginResponse)
		checkResponse(loginResponse, "Login failed for receiver " & receiverIP, jqPath)
		
		-- Debug marker BEFORE source retrieval
		debugOutput("STEP C: Retrieving sources from " & receiverIP)
		
		-- (C) Retrieve the list of available sources using session cookie
		set getSourcesURL to "http://" & receiverIP & "/mwapi?method=get-ndi-sources"
		set jsonResponse to runCURLWithSession(getSourcesURL, connectTimeout)
		debugOutput("JSON Response for " & receiverIP & ": " & jsonResponse)
		checkResponse(jsonResponse, "Failed to retrieve sources for receiver " & receiverIP, jqPath)
		
		-- Debug marker BEFORE source filtering
		debugOutput("STEP D: Filtering sources for " & receiverIP)
		
		-- (D) Use jq to filter sources for the desired receiver IP
		set desiredIP to receiverIP
		set jqQuery to ".sources[] | select(.\"ndi-name\" | contains(\"" & desiredIP & "\"))"
		set targetSourceRaw to do shell script "echo " & quoted form of jsonResponse & " | " & jqPath & " '" & jqQuery & "'"
		debugOutput("jq target source for " & receiverIP & ": " & targetSourceRaw)
		
		if targetSourceRaw is not "" then
			-- Debug marker BEFORE source extraction
			debugOutput("STEP E: Extracting NDI name for " & receiverIP)
			
			-- (E) Extract the ndi-name field using jq and remove extra quotes
			set ndiNameRaw to do shell script "echo " & quoted form of targetSourceRaw & " | " & jqPath & " '.\"ndi-name\"' | tr -d '\"'"
			debugOutput("NDI Name for " & receiverIP & ": " & ndiNameRaw)
			set encodedNdiName to urlEncode(ndiNameRaw)
			debugOutput("Encoded NDI Name for " & receiverIP & ": " & encodedNdiName)
			
			-- Debug marker BEFORE channel setting
			debugOutput("STEP F: Setting channel for " & receiverIP)
			
			-- (F) Set the receiver's channel to the found source
			set setChannelURL to "http://" & receiverIP & "/mwapi?method=set-channel&ndi-name=true&name=" & encodedNdiName
			set setChannelResponse to runCURLWithSession(setChannelURL, connectTimeout)
			debugOutput("Set Channel Response for " & receiverIP & ": " & setChannelResponse)
			checkResponse(setChannelResponse, "Set channel for receiver " & receiverIP, jqPath)
			
			set receiverResult's status to "Success"
			set receiverResult's source to ndiNameRaw
		else
			set receiverResult's status to "Fail (No valid source found)"
			set receiverResult's source to "N/A"
		end if
		
		-- Debug marker BEFORE logout
		debugOutput("STEP G: Logging out from " & receiverIP)
		
		-- (G) Logout from the receiver
		set logoutURL to "http://" & receiverIP & "/mwapi?method=logout"
		runCURLWithSession(logoutURL, connectTimeout)
		
	on error errMsg
		debugOutput("ERROR processing receiver " & receiverIP & ": " & errMsg)
	end try
	
	-- Append the result for this receiver to the summaryResults list
	set end of summaryResults to receiverResult
	debugOutput("Finished processing receiver: " & receiverIP)
end repeat


-- Calculate elapsed time
set endTimeSeconds to do shell script "date +%s"
set elapsedSeconds to (endTimeSeconds as number) - (startTimeSeconds as number)
set elapsedFormatted to my formatSeconds(elapsedSeconds)

-- Build and Display the Summary Dialog with timing information
set summaryText to "Receiver Summary:" & return & return
set summaryText to summaryText & "Total time: " & elapsedFormatted & return & return
repeat with res in summaryResults
	set summaryText to summaryText & "Receiver: " & (res's receiver) & return
	set summaryText to summaryText & "Status: " & (res's status) & return
	set summaryText to summaryText & "Source set: " & (res's source) & return & return
end repeat

display dialog summaryText buttons {"OK"} default button "OK"


-----------------------------------------------------
-- Utility Functions
-----------------------------------------------------
-- Find jq executable path
on findJQPath()
	set possiblePaths to {"/usr/local/bin/jq", "/usr/bin/jq", "/opt/homebrew/bin/jq", "~/bin/jq"}
	
	-- First try the which command to find it in PATH
	try
		set jqPathFromEnv to do shell script "which jq"
		if jqPathFromEnv is not "" then
			-- Found jq in PATH
			debugOutput("Found jq in PATH: " & jqPathFromEnv)
			return jqPathFromEnv
		end if
	on error
		-- which command failed, jq might not be in PATH
	end try
	
	-- Check each possible location
	repeat with testPath in possiblePaths
		try
			-- Expand path if it contains tilde
			if testPath begins with "~/" then
				set homeFolder to POSIX path of (path to home folder)
				set testPath to homeFolder & text 3 thru -1 of testPath
			end if
			
			-- Test if jq exists at this path
			do shell script "[ -x " & quoted form of testPath & " ]"
			debugOutput("Found jq at: " & testPath)
			return testPath
		on error
			-- Not found at this path, continue checking
		end try
	end repeat
	
	-- Not found in any location
	return ""
end findJQPath


-- Load configuration from file with flexible location detection
on loadConfiguration(jqPath)
	set configResult to {success:false, userName:"", userPW:"", receiverList:{}, connectTimeout:4}
	set configPath to missing value
	
	-- First, try to determine if we're running in QLab
	set runningInQLab to false
	try
		tell application "QLab" to get q number
		set runningInQLab to true
	on error
		-- Not running in QLab or QLab isn't open
		set runningInQLab to false
	end try
	
	-- Try to find config based on context (QLab or standalone)
	if runningInQLab then
		-- In QLab: Look for config file relative to the current workspace
		try
			tell application "QLab"
				if exists front workspace then
					set showfilePath to path of front workspace
					-- Extract directory from the full path
					set showfileFolder to do shell script "dirname " & quoted form of showfilePath
					set defaultConfigPath to showfileFolder & "/" & configFileName
					
					-- Check if config exists in the showfile's directory
					tell application "System Events"
						if exists file defaultConfigPath then
							set configPath to defaultConfigPath
							debugOutput("Found config file in QLab workspace folder: " & configPath)
						end if
					end tell
				end if
			end tell
		on error qlabErr
			debugOutput("Error checking QLab workspace location: " & qlabErr)
		end try
	else
		-- Standalone: Look for config in the script's directory
		try
			set scriptPath to path to me
			set scriptFolder to container of scriptPath as text
			set defaultConfigPath to scriptFolder & configFileName
			
			tell application "System Events"
				if exists file defaultConfigPath then
					set configPath to defaultConfigPath
					debugOutput("Found config file in script folder: " & configPath)
				end if
			end tell
		on error scriptErr
			debugOutput("Error checking script location: " & scriptErr)
		end try
	end if
	
	-- If still not found, try Documents folder as a fallback
	if configPath is missing value then
		set docsConfigPath to (path to documents folder as text) & configFileName
		tell application "System Events"
			if exists file docsConfigPath then
				set configPath to docsConfigPath
				debugOutput("Found config file in Documents folder: " & configPath)
			end if
		end tell
	end if
	
	-- If still not found, prompt user to select it
	if configPath is missing value then
		try
			set userPrompt to "Configuration file (" & configFileName & ") not found." & return & return & "Please select the configuration file:"
			set defaultLocation to path to documents folder
			set selectedFile to choose file with prompt userPrompt default location defaultLocation
			set configPath to selectedFile as text
			debugOutput("User selected config file: " & configPath)
		on error
			display dialog "No configuration file selected. Cannot continue." buttons {"OK"} default button "OK" with icon stop
			return configResult
		end try
	end if
	
	-- Now validate and parse the JSON file
	try
		set configFile to open for access configPath
		set configData to read configFile
		close access configFile
		
		-- Validate JSON structure before extracting fields
		try
			do shell script "echo " & quoted form of configData & " | " & jqPath & " ."
		on error jqError
			display dialog "The configuration file contains invalid JSON:" & return & return & jqError buttons {"OK"} default button "OK" with icon stop
			return configResult
		end try
		
		-- Extract individual fields with error handling for each
		try
			set configResult's userName to do shell script "echo " & quoted form of configData & " | " & jqPath & " -r '.userName'"
			if configResult's userName is "" or configResult's userName is "null" then error "userName is missing or empty"
		on error fieldErr
			display dialog "Error in configuration file: userName field is invalid or missing." buttons {"OK"} default button "OK" with icon stop
			return configResult
		end try
		
		try
			set configResult's userPW to do shell script "echo " & quoted form of configData & " | " & jqPath & " -r '.userPW'"
			if configResult's userPW is "" or configResult's userPW is "null" then error "userPW is missing or empty"
		on error fieldErr
			display dialog "Error in configuration file: userPW field is invalid or missing." buttons {"OK"} default button "OK" with icon stop
			return configResult
		end try
		
		try
			-- Verify receiverList exists and is an array
			do shell script "echo " & quoted form of configData & " | " & jqPath & " '.receiverList | type'"
			set receiverListType to do shell script "echo " & quoted form of configData & " | " & jqPath & " -r '.receiverList | type'"
			
			if receiverListType is not "array" then
				display dialog "Error in configuration file: receiverList must be an array." buttons {"OK"} default button "OK" with icon stop
				return configResult
			end if
			
			set configResult's receiverList to paragraphs of (do shell script "echo " & quoted form of configData & " | " & jqPath & " -r '.receiverList[]'")
			
			if (count of configResult's receiverList) is 0 or configResult's receiverList is {"null"} then
				display dialog "Error in configuration file: receiverList is empty." buttons {"OK"} default button "OK" with icon stop
				return configResult
			end if
		on error fieldErr
			display dialog "Error in configuration file: receiverList field is invalid or missing." & return & return & fieldErr buttons {"OK"} default button "OK" with icon stop
			return configResult
		end try
		
		-- First check if the connectTimeout field exists at all
		set hasTimeout to do shell script "echo " & quoted form of configData & " | " & jqPath & " -r 'has(\"connectTimeout\")'"
		
		if hasTimeout is "true" then
			-- Field exists, get its value and check its type
			set timeoutType to do shell script "echo " & quoted form of configData & " | " & jqPath & " -r '.connectTimeout | type'"
			
			if timeoutType is "number" then
				-- It's a number, use it directly
				set timeoutValue to do shell script "echo " & quoted form of configData & " | " & jqPath & " -r '.connectTimeout'"
				set configResult's connectTimeout to timeoutValue as number
			else if timeoutType is "string" then
				-- It's a string, try to convert to number
				set timeoutStr to do shell script "echo " & quoted form of configData & " | " & jqPath & " -r '.connectTimeout'"
				try
					set configResult's connectTimeout to timeoutStr as number
				on error
					display dialog "Error in configuration file: connectTimeout must be a number, got \"" & timeoutStr & "\"" buttons {"OK"} default button "OK" with icon stop
					return configResult
				end try
			else if timeoutType is "null" then
				-- It's explicitly null, use default
				set configResult's connectTimeout to 4
			else
				-- It's some other type (boolean, object, array)
				display dialog "Error in configuration file: connectTimeout must be a number, got " & timeoutType buttons {"OK"} default button "OK" with icon stop
				return configResult
			end if
		else
			-- Field doesn't exist at all, use default
			set configResult's connectTimeout to 4
			debugOutput("connectTimeout not found in config, using default: 4")
		end if
		
		set configResult's success to true
		debugOutput("Configuration loaded successfully from: " & configPath)
		return configResult
	on error errMsg
		display dialog "Failed to load configuration: " & errMsg buttons {"OK"} default button "OK" with icon stop
		return configResult
	end try
end loadConfiguration


-- Check receiver availability (both network and API)
on checkReceiverAvailability(receiverIP, jqPath)
	-- Initialize all local variables at the start
	set pingSuccess to false
	set apiSuccess to false
	set errorMessage to ""
	
	-- Debug timestamp before network check
	debugOutput("Starting network ping check for " & receiverIP & "...")
	
	-- Stage 1: Check basic network connectivity with strict timeout
	try
		-- Use a very short timeout to avoid hanging - with debugging output
		set pingCmd to "ping -c 1 -W 0.5 -t 1 " & receiverIP & " 2>&1 || echo 'Ping timeout'"
		debugOutput("Running ping command: " & pingCmd)
		
		set pingResponse to do shell script pingCmd
		
		-- Log raw response for debugging
		debugOutput("Raw ping response for " & receiverIP & ": " & pingResponse)
		
		if pingResponse contains "1 packets transmitted, 1 packets received" then
			set pingSuccess to true
			debugOutput("Network ping successful for " & receiverIP)
		else
			set errorMessage to "Network ping failed: " & pingResponse
			debugOutput("Network ping failed for " & receiverIP & ": " & pingResponse)
			-- Return early with just ping results
			return {reachable:pingSuccess, apiAvailable:apiSuccess, message:errorMessage}
		end if
	on error pingErr
		set errorMessage to "Network error: " & pingErr
		debugOutput("Network ping error for " & receiverIP & ": " & pingErr)
		-- Return early with just ping results
		return {reachable:pingSuccess, apiAvailable:apiSuccess, message:errorMessage}
	end try
	
	-- Only proceed to API check if ping was successful
	if not pingSuccess then
		return {reachable:pingSuccess, apiAvailable:apiSuccess, message:errorMessage}
	end if
	
	-- Debug timestamp before API check
	debugOutput("Starting API ping check for " & receiverIP & "...")
	
	-- Stage 2: Check API availability with strict timeout
	try
		set apiPingURL to "http://" & receiverIP & "/mwapi?method=ping"
		-- Force a very short timeout to avoid hanging
		set curlCmd to "curl --max-time 2 --connect-timeout 1 --silent " & quoted form of apiPingURL & " || echo '{\"status\":\"timeout\"}'"
		
		debugOutput("Running curl command: " & curlCmd)
		
		set apiResponse to do shell script curlCmd
		
		-- Log raw response for debugging
		debugOutput("Raw API response for " & receiverIP & ": " & apiResponse)
		
		-- Verify it's a valid response
		set isValidResponse to false
		try
			set jqCmd to "echo " & quoted form of apiResponse & " | " & jqPath & " '.status' 2>/dev/null || echo 'parse_error'"
			debugOutput("Running jq command: " & jqCmd)
			
			set statusCheck to do shell script jqCmd
			debugOutput("Status check result: " & statusCheck)
			
			if statusCheck as text is "0" then
				set isValidResponse to true
			end if
		end try
		
		if isValidResponse then
			set apiSuccess to true
			set errorMessage to "Receiver available"
			debugOutput("API ping successful for " & receiverIP)
		else
			set errorMessage to "API ping failed: Invalid response - " & apiResponse
			debugOutput("API ping failed for " & receiverIP & ": Invalid response - " & apiResponse)
		end if
	on error apiErr
		set errorMessage to "API error: " & apiErr
		debugOutput("API ping error for " & receiverIP & ": " & apiErr)
	end try
	
	debugOutput("Completed availability check for " & receiverIP)
	
	-- Create and return final result record
	return {reachable:pingSuccess, apiAvailable:apiSuccess, message:errorMessage}
end checkReceiverAvailability


-- Login to receiver and capture session cookie
on loginToReceiver(receiverIP, userName, userPW, connectTimeout)
	set loginURL to "http://" & receiverIP & "/mwapi?method=login&id=" & userName & "&pass=" & userPW
	
	-- Get the login response with headers
	set loginCmd to "curl -i --connect-timeout " & connectTimeout & " --max-time " & (connectTimeout * 2) & " --silent " & quoted form of loginURL
	debugOutput("Login command: " & loginCmd)
	set fullLoginResponse to do shell script loginCmd
	
	-- Log the complete response for debugging
	debugOutput("Full login response: " & fullLoginResponse)
	
	-- Extract the session ID from the Set-Cookie header
	try
		set cookieCmd to "echo " & quoted form of fullLoginResponse & " | grep -i 'Set-Cookie:' | awk -F'[=;]' '{print $2}'"
		set sessionID to do shell script cookieCmd
		debugOutput("Extracted session ID: " & sessionID)
		
		-- Store the cookie in the correct format
		if sessionID is not "" then
			set sessionCookie to "sid=" & sessionID
			debugOutput("Set cookie to: " & sessionCookie)
			-- Return success response since we got a session ID
			return "{\"status\": 0}"
		else
			set sessionCookie to ""
			debugOutput("No session ID found in response")
			-- Return error if no session ID found
			return "{\"status\": -1, \"error\": \"No session ID in response\"}"
		end if
	on error cookieErr
		set sessionCookie to ""
		debugOutput("Error extracting cookie: " & cookieErr)
		-- Return error for extraction failure
		return "{\"status\": -1, \"error\": \"Failed to extract cookie: " & cookieErr & "\"}"
	end try
end loginToReceiver


-- Run curl command with session cookie
on runCURLWithSession(theURL, connectTimeout)
	if sessionCookie is "" then
		-- No cookie available, just run a simple curl command
		set curlCmd to "curl --connect-timeout " & connectTimeout & " --max-time " & (connectTimeout * 2) & " --silent " & quoted form of theURL
		debugOutput("Running curl command (no cookie): " & curlCmd)
		return do shell script curlCmd
	else
		-- Use the stored session cookie in the format "sid=SESSIONID"
		set curlCmd to "curl --connect-timeout " & connectTimeout & " --max-time " & (connectTimeout * 2) & " --silent -b " & quoted form of sessionCookie & " " & quoted form of theURL
		debugOutput("Running curl command (with cookie): " & curlCmd)
		return do shell script curlCmd
	end if
end runCURLWithSession


-- URL Encode function (unchanged)
on urlEncode(input)
	try
		set encoded to do shell script "python3 -c 'import urllib.parse; print(urllib.parse.quote(\"" & input & "\"))'"
		return encoded
	on error errMsg
		error "URL Encoding failed: " & errMsg
	end try
end urlEncode


-- Check API response
on checkResponse(response, errorMessage, jqPath)
	try
		set jqCmd to "echo " & quoted form of response & " | " & jqPath & " '.status'"
		debugOutput("Running status check: " & jqCmd)
		set statusValue to do shell script jqCmd
		if statusValue as text is not "0" then
			error errorMessage & " failed. Response: " & response
		end if
	on error errMsg
		error errorMessage & " (jq parse error: " & errMsg & "). Full Response: " & response
	end try
end checkResponse


-- Format seconds into minutes and seconds
on formatSeconds(totalSeconds)
	set minutes to totalSeconds div 60
	set remainingSeconds to totalSeconds mod 60
	if minutes > 0 then
		return minutes & " min " & remainingSeconds & " sec"
	else
		return totalSeconds & " seconds"
	end if
end formatSeconds


-- Enhanced debug output function
on debugOutput(msg)
	set currentDate to do shell script "date '+%Y-%m-%d %H:%M:%S.%N'"
	set logMsg to "[" & currentDate & "] " & msg
	
	-- Log to the console
	log logMsg
end debugOutput
