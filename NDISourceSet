-----------------------------------------------------
-- NDI Receiver Management Script
-- Version: 2.1 Debug
-- Purpose: Automatically configures NDI receivers to use the correct source based on IP address
-----------------------------------------------------


-----------------------------------------------------
-- Script Properties
-----------------------------------------------------
property configFileName : "NDIReceiverConfig.json"
property debugMode : true -- Enable debug mode


-----------------------------------------------------
-- Main Script
-----------------------------------------------------
-- Start debugging output if debugMod is enabled
if debugMode then
	set debugResponse to display dialog "Debug mode enabled. Press OK to start execution or Cancel to abort." buttons {"Cancel", "OK"} default button "OK" with icon caution
	
	if button returned of debugResponse is "Cancel" then
		-- User canceled execution
		return -- Exit the script
	end if
	
	debugOutput("NDI Receiver Management Script starting...")
end if


-- Find jq path dynamically
debugOutput("Determining path to jq and verifying installation.")
set jqPath to findJQPath()
if jqPath is "" then
	display dialog "Could not find jq. Please install jq and try again." & return & return & "You can install jq with Homebrew:" & return & "brew install jq" buttons {"OK"} default button "OK" with icon stop
	return -- Exit the script
end if
debugOutput("Found jq installation at: " & jqPath)


-- Load configuration from file
set config to loadConfiguration(jqPath)
if not config's success then
	return -- Exit if config can't be loaded
end if


-- Extract configuration values
set userName to config's userName
set userPW to config's userPW
set connectTimeout to config's connectTimeout
set retryAttempts to config's retryAttempts
set retryDelay to config's retryDelay
set pingConfig to config's pingConfig
set pingTimeout to pingTimeout of pingConfig
set pingAttempts to pingAttempts of pingConfig
set pingWaitTime to pingWaitTime of pingConfig
set receiverList to config's receiverList
debugOutput("Count of receivers to process: " & (count of receiverList))
debugOutput("Retry attempts configured: " & retryAttempts)
my debugOutput("Retry delay configured: " & retryDelay)
debugOutput("Ping configuration: timeout=" & pingTimeout & ", attempts=" & pingAttempts & ", waitTime=" & pingWaitTime)

-- At the beginning of the script, after loading configuration, display warning to user prior to proceeding
display dialog "About to set channels for " & (count of receiverList) & " NDI receivers." & return & return & "This will take a few moments during which there will be no progress indication on the screen." & return & return & "Please be patient. A summary will be displayed when complete." buttons {"OK", "Cancel"} default button "OK"
if button returned of result is "Cancel" then
	return -- Exit if user cancels
end if


-- Record start time in seconds
set startTimeSeconds to do shell script "date +%s"


-- This list will accumulate summary records for each receiver
set summaryResults to {}


-- Main multi-pass processing loop with retry logic
my debugOutput("Beginning processing with retry capability (max retry attempts: " & retryAttempts & ")")

-- Create a tracking record for each receiver
-- Initialize a tracking record for each receiver
set receiverTrackingList to {}
repeat with receiverInfo in receiverList
	set receiverIP to theIp of receiverInfo
	-- Each record has the receiver info, result, and success flags
	set receiverRecord to {theReceiverInfo:receiverInfo, theResult:{receiver:receiverIP, status:"Not processed", source:"N/A"}, isSuccess:false, wasRetried:false}
	set end of receiverTrackingList to receiverRecord
end repeat

-- Main loop with retry logic
set currentPass to 1
set maxPasses to retryAttempts + 1
set allSuccessful to false

repeat until allSuccessful or currentPass > maxPasses
	my debugOutput("Starting pass " & currentPass & " of maximum " & maxPasses & " passes.")
	
	-- Track if we've processed all receivers successfully in this pass
	set allSuccessful to true
	set processedAny to false
	
	-- Process each receiver that hasn't succeeded yet
	repeat with i from 1 to count of receiverTrackingList
		set receiverRecord to item i of receiverTrackingList
		
		-- Only process receivers that haven't succeeded yet
		if not (isSuccess of receiverRecord) then
			set processedAny to true
			set receiverInfo to theReceiverInfo of receiverRecord
			set receiverIP to theIp of receiverInfo
			
			-- Show appropriate pass information
			if currentPass > 1 then
				set passText to "Retry pass " & (currentPass - 1) & ": "
			else
				set passText to "Initial pass: "
			end if
			
			my debugOutput(passText & "Processing receiver " & receiverIP)
			
			-- Process the receiver with full receiver info
			set receiverResult to processReceiver(receiverInfo, userName, userPW, connectTimeout, jqPath, pingTimeout, pingAttempts, pingWaitTime)
			
			-- Update the tracking record with the result
			set theResult of item i of receiverTrackingList to receiverResult
			
			-- If this is a retry, mark it as retried
			if currentPass > 1 then
				set wasRetried of item i of receiverTrackingList to true
			end if
			
			-- Check if it succeeded
			if (status of receiverResult) starts with "Success" then
				set isSuccess of item i of receiverTrackingList to true
				my debugOutput("Receiver " & receiverIP & " processed successfully")
			else
				-- This receiver failed, so we don't have all successful yet
				set allSuccessful to false
				my debugOutput("Receiver " & receiverIP & " failed, may retry in next pass")
			end if
		end if
	end repeat
	
	-- If we didn't process any receivers in this pass, we're done
	if not processedAny then
		my debugOutput("No receivers needed processing in pass " & currentPass)
		set allSuccessful to true
	end if
	
	-- Increment pass counter and add delay between passes
	set currentPass to currentPass + 1
	
	if not allSuccessful and currentPass ≤ maxPasses then
		set waitTime to retryDelay
		
		-- Count receivers that need retry by checking which ones haven't succeeded
		set failedCount to 0
		repeat with i from 1 to count of receiverTrackingList
			set receiverRecord to item i of receiverTrackingList
			if not (isSuccess of receiverRecord) then
				set failedCount to failedCount + 1
			end if
		end repeat
		
		set totalCount to count of receiverTrackingList
		set successCount to totalCount - failedCount
		
		-- Build the retry message with explicit text conversions
		set retryMessage to (failedCount as text) & " of " & (totalCount as text) & " receivers failed."
		set retryMessage to retryMessage & return & return
		set retryMessage to retryMessage & "Retry pass " & ((currentPass - 1) as text) & " of " & (retryAttempts as text) & " will begin in " & (retryDelay as text) & " seconds."
		set retryMessage to retryMessage & return & return
		set retryMessage to retryMessage & "Press Cancel to quit."
		
		my debugOutput("Showing retry dialog: " & retryMessage)
		
		-- Show the dialog with auto-dismiss after configured delay
		try
			display dialog retryMessage buttons {"Cancel"} default button "Cancel" with title "NDI Receiver Retry" with icon caution giving up after retryDelay
			-- Check if user clicked Cancel
			if button returned of result is "Cancel" then
				my debugOutput("User canceled retry.")
				exit repeat
			end if
		on error errMsg
			if errMsg contains "User canceled" then
				-- Dialog was canceled by user
				my debugOutput("User canceled retry.")
				exit repeat
			else if errMsg contains "-1708" or errMsg contains "gave up" then
				-- Dialog timed out, which is what we want
				my debugOutput("Retry dialog timed out, continuing with next pass.")
			else
				-- Some other error occurred
				my debugOutput("Error with retry dialog: " & errMsg)
			end if
		end try
		
		-- No additional delay needed since dialog provided it
	else if not allSuccessful then
		-- No more retries left, but some receivers still failed
		set failedCount to 0
		repeat with i from 1 to count of receiverTrackingList
			set receiverRecord to item i of receiverTrackingList
			if not (isSuccess of receiverRecord) then
				set failedCount to failedCount + 1
			end if
		end repeat
		
		set totalCount to count of receiverTrackingList
		my debugOutput("All retry attempts completed. " & (failedCount as text) & " of " & (totalCount as text) & " receivers still failed.")
	end if
end repeat

-- Build final summary list for compatibility with existing code
set summaryResults to {}
repeat with receiverRecord in receiverTrackingList
	set end of summaryResults to theResult of receiverRecord
end repeat

-- Add retry information to summary
set passesCompleted to currentPass - 1
if passesCompleted > 1 then
	if passesCompleted > 2 then
		set retryInfo to "Completed " & passesCompleted & " passes (initial + " & (passesCompleted - 1) & " retry passes)"
	else
		set retryInfo to "Completed " & passesCompleted & " passes (initial + " & (passesCompleted - 1) & " retry pass)"
	end if
else
	set retryInfo to "Completed in a single pass (no retries needed)"
end if
my debugOutput(retryInfo)


-- Calculate elapsed time
set endTimeSeconds to do shell script "date +%s"
set elapsedSeconds to (endTimeSeconds as number) - (startTimeSeconds as number)
set elapsedFormatted to my formatSeconds(elapsedSeconds)


-- Analyze the overall status
set totalReceivers to count of receiverTrackingList
set successCount to 0
set retryCount to 0
set failCount to 0

repeat with receiverRecord in receiverTrackingList
	if isSuccess of receiverRecord then
		set successCount to successCount + 1
		
		-- Count how many succeeded after a retry
		if wasRetried of receiverRecord then
			set retryCount to retryCount + 1
		end if
	else
		set failCount to failCount + 1
	end if
end repeat

my debugOutput("Results: " & successCount & " of " & totalReceivers & " successful (" & retryCount & " required retry), " & failCount & " failed.")

-- Determine the appropriate icon based on success/failure ratio
set dialogIcon to missing value
set statusSummary to ""

if successCount = totalReceivers then
	-- All receivers succeeded
	set dialogIcon to note
	set statusSummary to "✅ All receivers configured successfully."
else if successCount > 0 then
	-- Some receivers succeeded
	set dialogIcon to caution
	set statusSummary to "⚠️ " & successCount & " of " & totalReceivers & " receivers configured successfully."
else
	-- No receivers succeeded
	set dialogIcon to stop
	set statusSummary to "❌ Failed to configure any receivers."
end if

-- Build and Display the Summary Dialog
my debugOutput("Preparing summary report.")
set summaryText to "NDI Receiver Summary:" & return & return & statusSummary & return & return & "Total time: " & elapsedFormatted & return & return

-- Display detailed results
repeat with receiverRecord in receiverTrackingList
	set currentResult to theResult of receiverRecord
	set currentReceiver to receiver of currentResult
	set currentStatus to status of currentResult
	set currentSource to source of currentResult
	set wasRetried to wasRetried of receiverRecord
	
	-- Get the receiver info to determine what matching was used
	set receiverInfo to theReceiverInfo of receiverRecord
	set matchType to theMatchType of receiverInfo
	set matchPattern to thePattern of receiverInfo
	set receiverIP to theIp of receiverInfo
	
	-- Create the "Source sought" text based on match type
	set sourceSoughtText to ""
	if matchType is "ip" then
		set sourceSoughtText to "Name contains " & receiverIP
	else if matchType is "contains" then
		set sourceSoughtText to "Name contains \"" & matchPattern & "\""
	else if matchType is "exact" then
		set sourceSoughtText to "Name is \"" & matchPattern & "\""
	else
		set sourceSoughtText to "Unknown match type: " & matchType
	end if
	
	-- Build the result text with the new "Source sought" line
	set summaryText to summaryText & "Receiver: " & currentReceiver & return
	set summaryText to summaryText & "Source sought: " & sourceSoughtText & return
	
	-- Add a symbol to each receiver status
	if currentStatus starts with "Success" then
		if wasRetried then
			-- Success after retry - show caution symbol
			set summaryText to summaryText & "Status: ⚠️ " & currentStatus & " (after retry)" & return
		else
			-- Success on first try
			set summaryText to summaryText & "Status: ✅ " & currentStatus & return
		end if
	else if currentStatus starts with "Unreachable" or currentStatus starts with "API" then
		set summaryText to summaryText & "Status: ❌ " & currentStatus & return
	else
		set summaryText to summaryText & "Status: ⚠️ " & currentStatus & return
	end if
	
	set summaryText to summaryText & "Source set: " & currentSource & return & return
end repeat

-- Display the dialog with the appropriate icon
my debugOutput("Displaying summary dialog")
display dialog summaryText buttons {"OK"} default button "OK" with title "NDI Receiver Setup Results" with icon dialogIcon


-----------------------------------------------------
-- Utility Functions
-----------------------------------------------------
-- Find jq executable path
on findJQPath()
	set possiblePaths to {"/usr/local/bin/jq", "/usr/bin/jq", "/opt/homebrew/bin/jq", "~/bin/jq"}
	
	-- First try the which command to find it in PATH
	try
		set jqPathFromEnv to do shell script "which jq"
		if jqPathFromEnv is not "" then
			-- Found jq in PATH
			debugOutput("Found jq in PATH: " & jqPathFromEnv)
			return jqPathFromEnv
		end if
	on error
		-- which command failed, jq might not be in PATH
	end try
	
	-- Check each possible location
	repeat with testPath in possiblePaths
		try
			-- Expand path if it contains tilde
			if testPath begins with "~/" then
				set homeFolder to POSIX path of (path to home folder)
				set testPath to homeFolder & text 3 thru -1 of testPath
			end if
			
			-- Test if jq exists at this path
			do shell script "[ -x " & quoted form of testPath & " ]"
			debugOutput("Found jq installation at: " & testPath)
			return testPath
		on error
			-- Not found at this path, continue checking
		end try
	end repeat
	
	-- Not found in any location
	return ""
end findJQPath


-- Check if QLab is running using bundle identifier
on isQLabRunning()
	my debugOutput("Checking if QLab is running.")
	
	try
		-- Use the bundle identifier for a more precise check
		set checkCmd to "osascript -e 'tell application \"System Events\" to return (exists process \"QLab\")'"
		set isRunning to do shell script checkCmd
		
		if isRunning is "true" then
			my debugOutput("QLab is running.")
			
			-- Check if there's an open workspace
			try
				-- Only attempt to communicate with QLab if it's running
				tell application "QLab"
					if exists front workspace then
						my debugOutput("QLab has an open workspace.")
						return {isRunning:true, hasWorkspace:true}
					else
						my debugOutput("QLab does not have an open workspace.")
						return {isRunning:true, hasWorkspace:false}
					end if
				end tell
			on error workspaceErr
				my debugOutput("Error checking QLab workspace: " & workspaceErr)
				return {isRunning:true, hasWorkspace:false}
			end try
		else
			my debugOutput("QLab is not running.")
			return {isRunning:false, hasWorkspace:false}
		end if
	on error checkErr
		my debugOutput("Error checking if QLab is running: " & checkErr)
		return {isRunning:false, hasWorkspace:false}
	end try
end isQLabRunning


-- Find the configuration file based on context
on findConfigFile(configFileName)
	set configPath to missing value
	set configResult to {found:false, filePath:""}
	
	my debugOutput("Searching for configuration file: " & configFileName)
	
	-- Check if we're running in QLab
	set qlabStatus to isQLabRunning()
	set runningInQLab to isRunning of qlabStatus and hasWorkspace of qlabStatus
	
	-- Try to find config based on context (QLab or standalone)
	if runningInQLab then
		-- In QLab: Look for config file relative to the current workspace
		try
			tell application "QLab"
				if exists front workspace then
					-- Get path which is apparently already in POSIX format in QLab 5
					set qLabPathPOSIX to path of front workspace as text
					my debugOutput("QLab workspace path: " & qLabPathPOSIX)
					
					-- Use dirname to get the directory
					set showfolderPOSIX to do shell script "dirname " & quoted form of qLabPathPOSIX
					set configPathPOSIX to showfolderPOSIX & "/" & configFileName
					my debugOutput("Looking for config at: " & configPathPOSIX)
					
					-- Check if file exists using shell command
					set fileCheckCmd to "test -f " & quoted form of configPathPOSIX & " && echo 'true' || echo 'false'"
					set fileExists to (do shell script fileCheckCmd) is "true"
					
					if fileExists then
						set configPath to configPathPOSIX
						my debugOutput("Found config file in QLab workspace folder: " & configPath)
					else
						my debugOutput("Config file not found in QLab workspace folder")
					end if
				end if
			end tell
		on error qlabErr
			my debugOutput("Error checking QLab workspace location: " & qlabErr)
		end try
	else
		-- Standalone: Look for config in the script's directory
		try
			-- Get script path in POSIX format
			set scriptPathPOSIX to POSIX path of (path to me)
			my debugOutput("Script POSIX path: " & scriptPathPOSIX)
			
			-- Use dirname to get the directory
			set scriptFolderPOSIX to do shell script "dirname " & quoted form of scriptPathPOSIX
			set configPathPOSIX to scriptFolderPOSIX & "/" & configFileName
			my debugOutput("Looking for config at: " & configPathPOSIX)
			
			-- Check if file exists using shell command
			set fileCheckCmd to "test -f " & quoted form of configPathPOSIX & " && echo 'true' || echo 'false'"
			set fileExists to (do shell script fileCheckCmd) is "true"
			
			if fileExists then
				set configPath to configPathPOSIX
				my debugOutput("Found config file in script folder: " & configPath)
			else
				my debugOutput("Config file not found in script folder")
			end if
		on error scriptErr
			my debugOutput("Error checking script location: " & scriptErr)
		end try
	end if
	
	-- If still not found, try Documents folder as a fallback
	if configPath is missing value then
		-- Get documents folder in POSIX format
		set docsFolderPOSIX to POSIX path of (path to documents folder)
		set configPathPOSIX to docsFolderPOSIX & configFileName
		my debugOutput("Looking for config in Documents folder: " & configPathPOSIX)
		
		-- Check if file exists using shell command
		set fileCheckCmd to "test -f " & quoted form of configPathPOSIX & " && echo 'true' || echo 'false'"
		set fileExists to (do shell script fileCheckCmd) is "true"
		
		if fileExists then
			set configPath to configPathPOSIX
			my debugOutput("Found config file in Documents folder: " & configPath)
		else
			my debugOutput("Config file not found in Documents folder")
		end if
	end if
	
	-- If still not found, prompt user to select it
	if configPath is missing value then
		my debugOutput("Config file not found in any standard location, prompting user")
		try
			set userPrompt to "Configuration file (" & configFileName & ") not found." & return & return & "Please select the configuration file:"
			set defaultLocation to path to documents folder
			set selectedFile to choose file with prompt userPrompt default location defaultLocation
			-- Convert selected file to POSIX path
			set configPath to POSIX path of selectedFile
			my debugOutput("User selected config file: " & configPath)
		on error selectErr
			my debugOutput("User canceled file selection or error occurred: " & selectErr)
			display dialog "No configuration file selected. Cannot continue." buttons {"OK"} default button "OK" with icon stop
			return configResult
		end try
	end if
	
	-- Return the result
	if configPath is not missing value then
		set found of configResult to true
		set filePath of configResult to configPath
		my debugOutput("Configuration file found at: " & configPath)
	end if
	
	return configResult
end findConfigFile


-- Parse a configuration file and extract settings
on parseConfigFile(configPathPOSIX, jqPath)
	my debugOutput("Parsing configuration file: " & configPathPOSIX)
	set configResult to {success:false, userName:"", userPW:"", receiverList:{}, connectTimeout:4, retryAttempts:2, retryDelay:4, pingConfig:{pingTimeout:1.0, pingAttempts:1, pingWaitTime:0.5}}
	
	try
		-- Read the file contents using shell command (more reliable with POSIX paths)
		set readCmd to "cat " & quoted form of configPathPOSIX
		set configData to do shell script readCmd
		my debugOutput("Successfully read config file, validating JSON structure")
	on error readErr
		my debugOutput("Error reading config file: " & readErr)
		display dialog "Failed to read configuration file: " & readErr buttons {"OK"} default button "OK" with icon stop
		return configResult
	end try
	
	-- Validate JSON structure before extracting fields
	try
		set jqCmd to "echo " & quoted form of configData & " | " & jqPath & " ."
		my debugOutput("Validating JSON structure with command: " & jqCmd)
		do shell script jqCmd
		my debugOutput("JSON structure validation successful")
	on error jqError
		my debugOutput("JSON validation error: " & jqError)
		display dialog "The configuration file contains invalid JSON:" & return & return & jqError buttons {"OK"} default button "OK" with icon stop
		return configResult
	end try
	
	-- Extract individual fields with error handling for each
	
	-- Extract userName
	try
		set jqCmd to "echo " & quoted form of configData & " | " & jqPath & " -r '.userName'"
		my debugOutput("Extracting userName with command: " & jqCmd)
		set configResult's userName to do shell script jqCmd
		my debugOutput("Extracted userName: " & configResult's userName)
		
		if configResult's userName is "" or configResult's userName is "null" then
			my debugOutput("ERROR: userName is missing or empty")
			error "userName is missing or empty"
		end if
	on error fieldErr
		my debugOutput("ERROR extracting userName: " & fieldErr)
		display dialog "Error in configuration file: userName field is invalid or missing." buttons {"OK"} default button "OK" with icon stop
		return configResult
	end try
	
	-- Extract userPW
	try
		set jqCmd to "echo " & quoted form of configData & " | " & jqPath & " -r '.userPW'"
		my debugOutput("Extracting userPW with command: " & jqCmd)
		set configResult's userPW to do shell script jqCmd
		my debugOutput("Extracted userPW: [REDACTED]") -- Don't log actual password
		
		if configResult's userPW is "" or configResult's userPW is "null" then
			my debugOutput("ERROR: userPW is missing or empty")
			error "userPW is missing or empty"
		end if
	on error fieldErr
		my debugOutput("ERROR extracting userPW: " & fieldErr)
		display dialog "Error in configuration file: userPW field is invalid or missing." buttons {"OK"} default button "OK" with icon stop
		return configResult
	end try
	
	-- Extract connectTimeout
	try
		-- Check if connectTimeout exists
		set hasTimeout to do shell script "echo " & quoted form of configData & " | " & jqPath & " -r 'has(\"connectTimeout\")'"
		my debugOutput("Checking if connectTimeout exists: " & hasTimeout)
		
		if hasTimeout is "true" then
			set timeoutType to do shell script "echo " & quoted form of configData & " | " & jqPath & " -r '.connectTimeout | type'"
			my debugOutput("connectTimeout type: " & timeoutType)
			
			if timeoutType contains "number" then
				set timeoutValue to do shell script "echo " & quoted form of configData & " | " & jqPath & " -r '.connectTimeout'"
				set configResult's connectTimeout to timeoutValue as number
				my debugOutput("Using connectTimeout from config: " & configResult's connectTimeout)
			else if timeoutType contains "string" then
				set timeoutStr to do shell script "echo " & quoted form of configData & " | " & jqPath & " -r '.connectTimeout'"
				my debugOutput("Got connectTimeout string: " & timeoutStr)
				try
					set configResult's connectTimeout to timeoutStr as number
					my debugOutput("Converted connectTimeout to number: " & configResult's connectTimeout)
				on error
					my debugOutput("ERROR: connectTimeout string could not be converted to number: " & timeoutStr)
					display dialog "Error in configuration file: connectTimeout must be a number, got \"" & timeoutStr & "\"" buttons {"OK"} default button "OK" with icon stop
					return configResult
				end try
			else if timeoutType contains "null" then
				set configResult's connectTimeout to 4
				my debugOutput("connectTimeout is null, using default: 4")
			else
				my debugOutput("ERROR: connectTimeout has invalid type: " & timeoutType)
				display dialog "Error in configuration file: connectTimeout must be a number, got " & timeoutType buttons {"OK"} default button "OK" with icon stop
				return configResult
			end if
		else
			my debugOutput("connectTimeout not found in config, using default: 4")
		end if
	on error timeoutErr
		my debugOutput("Error extracting connectTimeout: " & timeoutErr & ", using default: 4")
	end try
	
	-- Extract retryAttempts
	try
		set hasRetryAttempts to do shell script "echo " & quoted form of configData & " | " & jqPath & " -r 'has(\"retryAttempts\")'"
		my debugOutput("Checking if retryAttempts exists: " & hasRetryAttempts)
		
		if hasRetryAttempts is "true" then
			set retryType to do shell script "echo " & quoted form of configData & " | " & jqPath & " -r '.retryAttempts | type'"
			my debugOutput("retryAttempts type: " & retryType)
			
			if retryType contains "number" then
				set retryValue to do shell script "echo " & quoted form of configData & " | " & jqPath & " -r '.retryAttempts'"
				set configResult's retryAttempts to retryValue as number
				my debugOutput("Using retryAttempts from config: " & configResult's retryAttempts)
			else
				my debugOutput("retryAttempts is not a number, using default: " & configResult's retryAttempts)
			end if
		else
			my debugOutput("retryAttempts not found in config, using default: " & configResult's retryAttempts)
		end if
	on error retryErr
		my debugOutput("Error parsing retryAttempts: " & retryErr & ", using default: " & configResult's retryAttempts)
	end try
	
	-- Extract retryDelay
	try
		set hasRetryDelay to do shell script "echo " & quoted form of configData & " | " & jqPath & " -r 'has(\"retryDelay\")'"
		my debugOutput("Checking if retryDelay exists: " & hasRetryDelay)
		
		if hasRetryDelay is "true" then
			set retryType to do shell script "echo " & quoted form of configData & " | " & jqPath & " -r '.retryDelay | type'"
			my debugOutput("retryDelay type: " & retryType)
			
			if retryType contains "number" then
				set retryValue to do shell script "echo " & quoted form of configData & " | " & jqPath & " -r '.retryDelay'"
				set configResult's retryDelay to retryValue as number
				my debugOutput("Using retryDelay from config: " & configResult's retryDelay)
			else
				my debugOutput("retryDelay is not a number, using default: " & configResult's retryDelay)
			end if
		else
			my debugOutput("retryDelay not found in config, using default: " & configResult's retryDelay)
		end if
	on error retryErr
		my debugOutput("Error parsing retryDelay: " & retryErr & ", using default: " & configResult's retryDelay)
	end try
	
	-- Extract ping configuration
	try
		set hasPingConfig to do shell script "echo " & quoted form of configData & " | " & jqPath & " -r 'has(\"pingConfig\")'"
		my debugOutput("Checking if pingConfig exists: " & hasPingConfig)
		
		if hasPingConfig is "true" then
			-- Extract ping timeout
			try
				set timeoutValue to do shell script "echo " & quoted form of configData & " | " & jqPath & " -r '.pingConfig.pingTimeout'"
				if timeoutValue is not "null" then
					set configResult's pingConfig's pingTimeout to timeoutValue as number
					my debugOutput("Using ping timeout from config: " & configResult's pingConfig's pingTimeout)
				end if
			on error
				my debugOutput("Using default ping timeout: " & configResult's pingConfig's pingTimeout)
			end try
			
			-- Extract ping attempts
			try
				set attemptsValue to do shell script "echo " & quoted form of configData & " | " & jqPath & " -r '.pingConfig.pingAttempts'"
				if attemptsValue is not "null" then
					set configResult's pingConfig's pingAttempts to attemptsValue as number
					my debugOutput("Using ping attempts from config: " & configResult's pingConfig's pingAttempts)
				end if
			on error
				my debugOutput("Using default ping attempts: " & configResult's pingConfig's pingAttempts)
			end try
			
			-- Extract ping wait time
			try
				set waitValue to do shell script "echo " & quoted form of configData & " | " & jqPath & " -r '.pingConfig.pingWaitTime'"
				if waitValue is not "null" then
					set configResult's pingConfig's pingWaitTime to waitValue as number
					my debugOutput("Using ping wait time from config: " & configResult's pingConfig's pingWaitTime)
				end if
			on error
				my debugOutput("Using default ping wait time: " & configResult's pingConfig's pingWaitTime)
			end try
		else
			my debugOutput("pingConfig not found in config, using defaults")
		end if
	on error configErr
		my debugOutput("Error parsing pingConfig: " & configErr & ", using defaults")
	end try
	
	-- Extract receiverList - check format first to handle both old and new format
	try
		-- Verify receiverList exists and is an array
		set jqCmd to "echo " & quoted form of configData & " | " & jqPath & " '.receiverList | type'"
		my debugOutput("Checking receiverList type with command: " & jqCmd)
		set receiverListType to do shell script jqCmd
		my debugOutput("receiverList type: " & receiverListType)
		
		if receiverListType does not contain "array" then
			my debugOutput("ERROR: receiverList must be an array, found type: " & receiverListType)
			display dialog "Error in configuration file: receiverList must be an array." buttons {"OK"} default button "OK" with icon stop
			return configResult
		end if
		
		-- Extract receiverList - check format first to handle both old and new format
		set firstItemCmd to "echo " & quoted form of configData & " | " & jqPath & " -r '.receiverList[0] | type' 2>/dev/null || echo 'unknown'"
		set firstItemType to do shell script firstItemCmd
		my debugOutput("First receiver item type: " & firstItemType)
		
		-- Variable to store the processed receiver list
		set processedReceiverList to {}
		
		if firstItemType contains "string" then
			-- Old format: simple array of IP strings
			my debugOutput("Using simple receiver list format (IP strings)")
			set ipListCmd to "echo " & quoted form of configData & " | " & jqPath & " -r '.receiverList[]'"
			set ipList to paragraphs of (do shell script ipListCmd)
			
			-- Convert to new format
			repeat with currentIP in ipList
				set receiverInfo to {theIp:currentIP, theMatchType:"ip", thePattern:""}
				set end of processedReceiverList to receiverInfo
			end repeat
			
			my debugOutput("Converted " & (count of processedReceiverList) & " IP addresses to receiver info objects")
		else if firstItemType contains "object" then
			-- New format: array of objects with ip, matchType, and optional pattern
			my debugOutput("Using enhanced receiver list format (with match types)")
			set receiverCount to do shell script "echo " & quoted form of configData & " | " & jqPath & " '.receiverList | length'"
			set receiverCount to receiverCount as number
			
			repeat with i from 0 to (receiverCount - 1)
				-- Extract IP (required)
				set ipCmd to "echo " & quoted form of configData & " | " & jqPath & " -r '.receiverList[" & i & "].ip'"
				set currentIP to do shell script ipCmd
				
				-- Extract matchType (default to "ip" if missing)
				set matchTypeCmd to "echo " & quoted form of configData & " | " & jqPath & " -r '.receiverList[" & i & "].matchType // \"ip\"'"
				set currentMatchType to do shell script matchTypeCmd
				
				-- Extract pattern (if applicable)
				set currentPattern to ""
				if currentMatchType is not "ip" then
					set patternCmd to "echo " & quoted form of configData & " | " & jqPath & " -r '.receiverList[" & i & "].pattern // \"\"'"
					set currentPattern to do shell script patternCmd
				end if
				
				-- Create receiver info record with proper AppleScript naming
				set receiverInfo to {theIp:currentIP, theMatchType:currentMatchType, thePattern:currentPattern}
				set end of processedReceiverList to receiverInfo
				
				my debugOutput("Parsed receiver " & (i + 1) & ": IP=" & currentIP & ", matchType=" & currentMatchType & ", pattern=" & currentPattern)
			end repeat
		else
			my debugOutput("ERROR: Unknown receiverList format")
			display dialog "Error in configuration file: Unrecognized receiverList format." buttons {"OK"} default button "OK" with icon stop
			return configResult
		end if
		
		-- Store the processed list in the config result
		set configResult's receiverList to processedReceiverList
		set receiverCount to count of processedReceiverList
		my debugOutput("Final processed receiver count: " & receiverCount)
		
		-- Format list for better debugging display
		set receiverDescriptions to ""
		repeat with i from 1 to receiverCount
			set currentInfo to item i of processedReceiverList
			set currentIP to theIp of currentInfo
			set currentMatchType to theMatchType of currentInfo
			
			if i > 1 then
				set receiverDescriptions to receiverDescriptions & ", "
			end if
			
			if currentMatchType is "ip" then
				set receiverDescriptions to receiverDescriptions & currentIP
			else
				set currentPattern to thePattern of currentInfo
				set receiverDescriptions to receiverDescriptions & currentIP & " (" & currentMatchType & ": " & currentPattern & ")"
			end if
		end repeat
		
		my debugOutput("Extracted " & receiverCount & " receivers: " & receiverDescriptions)
		
		if receiverCount is 0 then
			my debugOutput("ERROR: receiverList is empty")
			display dialog "Error in configuration file: receiverList is empty." buttons {"OK"} default button "OK" with icon stop
			return configResult
		end if
	on error fieldErr
		my debugOutput("ERROR extracting receiverList: " & fieldErr)
		display dialog "Error in configuration file: receiverList field is invalid or missing." & return & return & fieldErr buttons {"OK"} default button "OK" with icon stop
		return configResult
	end try
	
	-- Set success flag and return
	set configResult's success to true
	my debugOutput("Configuration parsed successfully")
	return configResult
end parseConfigFile


-- Load configuration: wrapper function that combines finding and parsing
on loadConfiguration(jqPath)
	my debugOutput("Starting configuration loading")
	
	-- Find the configuration file
	set fileResult to findConfigFile(configFileName)
	
	if not (found of fileResult) then
		my debugOutput("Configuration file not found")
		return {success:false}
	end if
	
	-- Parse the configuration file using the POSIX path
	set configPath to filePath of fileResult
	set configResult to parseConfigFile(configPath, jqPath)
	
	return configResult
end loadConfiguration


-- Check receiver availability (both network and API)
on checkReceiverAvailability(receiverIP, jqPath, pingTimeout, pingAttempts, pingWaitTime)
	set availabilityResult to {reachable:false, apiAvailable:false, message:""}
	
	-- Stage 1: Check basic network connectivity with configurable parameters
	my debugOutput("Starting network ping check for " & receiverIP & " (timeout=" & pingTimeout & ", attempts=" & pingAttempts & ")")
	
	set pingSuccess to false
	set attemptCount to 0
	
	repeat pingAttempts times
		set attemptCount to attemptCount + 1
		my debugOutput("Ping attempt " & attemptCount & " of " & pingAttempts)
		
		try
			-- Construct ping command with configurable parameters
			set pingCmd to "ping -c 1 -W " & pingTimeout & " -t " & pingTimeout & " " & receiverIP & " 2>&1 || echo 'Ping timeout'"
			my debugOutput("Running ping command: " & pingCmd)
			
			set pingResponse to do shell script pingCmd
			my debugOutput("Raw ping response for " & receiverIP & ": " & pingResponse)
			
			-- Check for packet loss rate directly from the ping output
			try
				-- Extract the packet loss percentage as a number
				set extractCmd to "echo " & quoted form of pingResponse & " | grep -o '[0-9]\\+\\(\\.[0-9]\\+\\)\\?% packet loss' | grep -o '[0-9]\\+\\(\\.[0-9]\\+\\)\\?'"
				set lossPercentageStr to do shell script extractCmd
				my debugOutput("Extracted loss percentage: " & lossPercentageStr)
				
				-- Convert to number for comparison
				set lossPercentage to lossPercentageStr as number
				my debugOutput("Loss percentage as number: " & lossPercentage)
				
				-- Check if loss percentage is 0
				if lossPercentage = 0 then
					my debugOutput("PING SUCCESS: 0% packet loss")
					set pingSuccess to true
					exit repeat
				else
					my debugOutput("PING FAILURE: " & lossPercentage & "% packet loss")
					-- Continue to next attempt
				end if
			on error extractErr
				-- If we can't extract the percentage, check for timeout
				if pingResponse contains "Ping timeout" then
					my debugOutput("PING FAILURE: Timeout detected")
					-- Continue to next attempt
				else if pingResponse contains "1 packets transmitted, 1 packets received" or ¬
					pingResponse contains "1 packets transmitted, 1 received" then
					my debugOutput("PING SUCCESS: Explicit success pattern")
					set pingSuccess to true
					exit repeat
				else
					my debugOutput("PING FAILURE: Could not determine status - " & extractErr)
					-- Continue to next attempt
				end if
			end try
			
			-- Wait between attempts if not successful and not the last attempt
			if not pingSuccess and attemptCount < pingAttempts then
				my debugOutput("Waiting " & pingWaitTime & " seconds before next ping attempt")
				delay pingWaitTime
			end if
		on error pingErr
			my debugOutput("Ping error on attempt " & attemptCount & " for " & receiverIP & ": " & pingErr)
			
			-- Wait between attempts if not the last attempt
			if attemptCount < pingAttempts then
				my debugOutput("Waiting " & pingWaitTime & " seconds before next ping attempt")
				delay pingWaitTime
			end if
		end try
	end repeat
	
	if pingSuccess then
		set availabilityResult's reachable to true
		my debugOutput("Network ping successful for " & receiverIP)
	else
		set availabilityResult's message to "Network ping failed after " & pingAttempts & " attempts"
		my debugOutput(availabilityResult's message)
		return availabilityResult
	end if
	
	-- Stage 2: Check API availability with strict timeout
	my debugOutput("Starting API ping check for " & receiverIP & "...")
	
	try
		set apiPingURL to "http://" & receiverIP & "/mwapi?method=ping"
		-- Force a short timeout to avoid hanging
		set curlCmd to "curl --max-time 2 --connect-timeout 1 --silent " & quoted form of apiPingURL & " || echo '{\"status\":\"timeout\"}'"
		
		my debugOutput("Running curl command: " & curlCmd)
		set apiResponse to do shell script curlCmd
		
		-- Log raw response for debugging
		my debugOutput("Raw API response for " & receiverIP & ": " & apiResponse)
		
		-- Verify it's a valid response
		set isValidResponse to false
		try
			set jqCmd to "echo " & quoted form of apiResponse & " | " & jqPath & " '.status' 2>/dev/null || echo 'parse_error'"
			my debugOutput("Running jq command: " & jqCmd)
			
			set statusCheck to do shell script jqCmd
			my debugOutput("Status check result: " & statusCheck)
			
			if statusCheck as text is "0" then
				set isValidResponse to true
			end if
		end try
		
		if isValidResponse then
			set availabilityResult's apiAvailable to true
			set availabilityResult's message to "Receiver available"
			my debugOutput("API ping successful for " & receiverIP)
		else
			set availabilityResult's message to "API ping failed: Invalid response - " & apiResponse
			my debugOutput("API ping failed for " & receiverIP & ": Invalid response - " & apiResponse)
		end if
	on error apiErr
		set availabilityResult's message to "API error: " & apiErr
		my debugOutput("API ping error for " & receiverIP & ": " & apiErr)
	end try
	
	my debugOutput("Completed availability check for " & receiverIP)
	return availabilityResult
end checkReceiverAvailability


-- Login to receiver and return both response and session cookie
on loginToReceiver(receiverIP, userName, userPW, connectTimeout)
	set loginURL to "http://" & receiverIP & "/mwapi?method=login&id=" & userName & "&pass=" & userPW
	
	-- Capture the cookie data from curl
	set loginCmd to "curl -i --connect-timeout " & connectTimeout & " --max-time " & (connectTimeout * 2) & " --silent " & quoted form of loginURL
	my debugOutput("Login command: " & loginCmd)
	set fullLoginResponse to do shell script loginCmd
	
	-- Extract the session ID from the Set-Cookie header
	set sessionID to ""
	set sessionCookie to ""
	
	try
		set cookieCmd to "echo " & quoted form of fullLoginResponse & " | grep -i 'Set-Cookie:' | awk -F'[=;]' '{print $2}'"
		set sessionID to do shell script cookieCmd
		my debugOutput("Extracted session ID: " & sessionID)
		
		if sessionID is not "" then
			set sessionCookie to "sid=" & sessionID
			my debugOutput("Set cookie to: " & sessionCookie)
		else
			my debugOutput("No session ID found in response")
		end if
	on error cookieErr
		my debugOutput("Error extracting cookie: " & cookieErr)
	end try
	
	-- Return a record with both the login response and the session cookie
	return {response:"{\"status\": 0}", cookie:sessionCookie}
end loginToReceiver


-- Process a single receiver and return the result
on processReceiver(receiverInfo, userName, userPW, connectTimeout, jqPath, pingTimeout, pingAttempts, pingWaitTime)
	set receiverIP to theIp of receiverInfo
	my debugOutput("Starting to process receiver: " & receiverIP)
	
	-- Initialize a result record
	set receiverResult to {receiver:receiverIP, status:"", source:""}
	
	try
		-- (A) Check if receiver is available (both network and API)
		my debugOutput("STEP A: Checking receiver availability for " & receiverIP)
		set availabilityStatus to checkReceiverAvailability(receiverIP, jqPath, pingTimeout, pingAttempts, pingWaitTime)
		
		if not availabilityStatus's reachable then
			set receiverResult's status to "Unreachable (network ping failed)"
			set receiverResult's source to "N/A"
			my debugOutput("Network unreachable for " & receiverIP & ": " & availabilityStatus's message)
			error "Skipping receiver " & receiverIP & " - network unreachable"
		else if not availabilityStatus's apiAvailable then
			set receiverResult's status to "API unavailable"
			set receiverResult's source to "N/A"
			my debugOutput("API unavailable for " & receiverIP & ": " & availabilityStatus's message)
			error "Skipping receiver " & receiverIP & " - API unavailable"
		end if
		
		-- (B) Login to the receiver to get a session cookie
		my debugOutput("STEP B: Logging in to " & receiverIP)
		set loginResult to loginToReceiver(receiverIP, userName, userPW, connectTimeout)
		set loginResponse to loginResult's response
		set sessionCookie to loginResult's cookie
		
		my debugOutput("Login Response for " & receiverIP & ": " & loginResponse)
		my checkResponse(loginResponse, "Login failed for receiver " & receiverIP, jqPath)
		
		-- (C) Retrieve the list of available sources using session cookie
		my debugOutput("STEP C: Retrieving sources from " & receiverIP)
		set getSourcesURL to "http://" & receiverIP & "/mwapi?method=get-ndi-sources"
		set jsonResponse to runCURLWithSession(getSourcesURL, connectTimeout, sessionCookie)
		my debugOutput("JSON Response for " & receiverIP & ": " & jsonResponse)
		my checkResponse(jsonResponse, "Failed to retrieve sources for receiver " & receiverIP, jqPath)
		
		-- (D) Find matching source for this receiver
		my debugOutput("STEP D: Finding matching source for " & receiverIP)
		set sourceResult to findMatchingSource(jsonResponse, receiverInfo, jqPath)
		
		if sourceResult's found then
			-- (E) Set the receiver's channel to the found source
			my debugOutput("STEP E: Setting channel for " & receiverIP)
			set setChannelURL to "http://" & receiverIP & "/mwapi?method=set-channel&ndi-name=true&name=" & sourceResult's encodedName
			set setChannelResponse to runCURLWithSession(setChannelURL, connectTimeout, sessionCookie)
			my debugOutput("Set Channel Response for " & receiverIP & ": " & setChannelResponse)
			my checkResponse(setChannelResponse, "Set channel for receiver " & receiverIP, jqPath)
			
			set receiverResult's status to "Success"
			set receiverResult's source to sourceResult's sourceName
		else
			set receiverResult's status to "Fail (No valid source found)"
			set receiverResult's source to "N/A"
		end if
		
		-- (F) Logout from the receiver
		my debugOutput("STEP F: Logging out from " & receiverIP)
		set logoutURL to "http://" & receiverIP & "/mwapi?method=logout"
		runCURLWithSession(logoutURL, connectTimeout, sessionCookie)
		
	on error errMsg
		my debugOutput("ERROR processing receiver " & receiverIP & ": " & errMsg)
	end try
	
	my debugOutput("Finished processing receiver: " & receiverIP)
	return receiverResult
end processReceiver


-- Find a matching NDI source for the given receiver
-- Replace your current findMatchingSource function with this enhanced version:

-- Find a matching NDI source for the given receiver
on findMatchingSource(jsonResponse, receiverInfo, jqPath)
	-- Create the result record
	set sourceResult to {found:false, sourceName:"", encodedName:""}
	
	set receiverIP to theIp of receiverInfo
	set matchType to matchType of receiverInfo
	set pattern to pattern of receiverInfo
	
	my debugOutput("Finding source for receiver " & receiverIP & " using match type: " & matchType)
	
	-- Build the appropriate jq query based on match type
	set jqQuery to ""
	
	if matchType is "ip" then
		-- IP matching: find sources containing the IP with proper boundaries
		set jqQuery to ".sources[] | select(.\"ndi-name\" | test(\"[^0-9]" & receiverIP & "[^0-9]|^" & receiverIP & "[^0-9]|[^0-9]" & receiverIP & "$|^" & receiverIP & "$\"))"
		my debugOutput("Using IP match query for " & receiverIP)
	else if matchType is "contains" then
		-- Contains matching: find sources containing the specified pattern
		set jqQuery to ".sources[] | select(.\"ndi-name\" | contains(\"" & pattern & "\"))"
		my debugOutput("Using CONTAINS match query for pattern: " & pattern)
	else if matchType is "exact" then
		-- Exact matching: find sources with the exact name specified
		set jqQuery to ".sources[] | select(.\"ndi-name\" == \"" & pattern & "\")"
		my debugOutput("Using EXACT match query for pattern: " & pattern)
	else
		-- Unknown match type - fall back to IP matching
		my debugOutput("WARNING: Unknown match type '" & matchType & "', falling back to IP matching")
		set jqQuery to ".sources[] | select(.\"ndi-name\" | test(\"[^0-9]" & receiverIP & "[^0-9]|^" & receiverIP & "[^0-9]|[^0-9]" & receiverIP & "$|^" & receiverIP & "$\"))"
	end if
	
	-- Use jq to find matching sources
	set targetSourceRaw to do shell script "echo " & quoted form of jsonResponse & " | " & jqPath & " '" & jqQuery & "'"
	my debugOutput("jq source query result for " & receiverIP & ": " & targetSourceRaw)
	
	if targetSourceRaw is not "" then
		-- Process found source as before
		set ndiNameRaw to do shell script "echo " & quoted form of targetSourceRaw & " | " & jqPath & " '.\"ndi-name\"' | tr -d '\"'"
		my debugOutput("NDI Name for " & receiverIP & ": " & ndiNameRaw)
		set encodedNdiName to urlEncode(ndiNameRaw)
		my debugOutput("Encoded NDI Name for " & receiverIP & ": " & encodedNdiName)
		
		-- Set result values
		set sourceResult's found to true
		set sourceResult's sourceName to ndiNameRaw
		set sourceResult's encodedName to encodedNdiName
	else
		my debugOutput("No matching source found for receiver " & receiverIP & " with " & matchType & " matching")
	end if
	
	return sourceResult
end findMatchingSource


-- Run curl command with explicit session cookie
on runCURLWithSession(theURL, connectTimeout, cookieValue)
	if cookieValue is "" then
		-- No cookie available, just run a simple curl command
		set curlCmd to "curl --connect-timeout " & connectTimeout & " --max-time " & (connectTimeout * 2) & " --silent " & quoted form of theURL
		my debugOutput("Running curl command (no cookie): " & curlCmd)
		return do shell script curlCmd
	else
		-- Use the provided session cookie
		set curlCmd to "curl --connect-timeout " & connectTimeout & " --max-time " & (connectTimeout * 2) & " --silent -b " & quoted form of cookieValue & " " & quoted form of theURL
		my debugOutput("Running curl command (with cookie): " & curlCmd)
		return do shell script curlCmd
	end if
end runCURLWithSession


-- URL Encode function
on urlEncode(input)
	debugOutput("URL encoding input: " & input)
	try
		set encoded to do shell script "python3 -c 'import urllib.parse; print(urllib.parse.quote(\"" & input & "\"))'"
		debugOutput("URL encoded result: " & encoded)
		return encoded
	on error errMsg
		debugOutput("URL Encoding failed: " & errMsg)
		error "URL Encoding failed: " & errMsg
	end try
end urlEncode


-- Check API response
on checkResponse(response, errorMessage, jqPath)
	debugOutput("Checking API response: " & response)
	try
		set jqCmd to "echo " & quoted form of response & " | " & jqPath & " '.status'"
		debugOutput("Running status check: " & jqCmd)
		
		set statusValue to do shell script jqCmd
		debugOutput("Status check result: " & statusValue)
		
		if statusValue as text is not "0" then
			debugOutput("API check FAILED: " & errorMessage)
			error errorMessage & " failed. Response: " & response
		else
			debugOutput("API check SUCCESS")
		end if
	on error errMsg
		debugOutput("API check ERROR: " & errMsg)
		error errorMessage & " (jq parse error: " & errMsg & "). Full Response: " & response
	end try
end checkResponse


-- Format seconds into minutes and seconds
on formatSeconds(totalSeconds)
	set minutes to totalSeconds div 60
	set remainingSeconds to totalSeconds mod 60
	if minutes > 0 then
		return minutes & " min " & remainingSeconds & " sec"
	else
		return totalSeconds & " seconds"
	end if
end formatSeconds


-- create joined list with delimiters
on joinListWithDelimiter(theList, theDelimiter)
	-- Save original delimiters
	set oldDelimiters to AppleScript's text item delimiters
	-- Set new delimiters
	set AppleScript's text item delimiters to theDelimiter
	-- Join the list
	set joinedText to theList as text
	-- Restore original delimiters
	set AppleScript's text item delimiters to oldDelimiters
	-- Return the result
	return joinedText
end joinListWithDelimiter


-- Enhanced debug output function
on debugOutput(msg)
	-- Only log if debug mode is enabled
	if debugMode then
		set currentDate to do shell script "date '+%Y-%m-%d %H:%M:%S.%N'"
		set logMsg to " [" & currentDate & "] " & msg & " "
		
		-- Log to the console
		log logMsg
	end if
end debugOutput
