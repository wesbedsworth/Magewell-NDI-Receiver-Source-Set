-----------------------------------------------------
-- NDI Receiver Management Script
-- Version: 2.1 Debug
-- Purpose: Automatically configures NDI receivers to use the correct source based on IP address
-----------------------------------------------------


-----------------------------------------------------
-- Script Properties
-----------------------------------------------------
property sessionCookie : ""
property configFileName : "NDIReceiverConfig.json"
property debugMode : true -- Enable debug mode


-----------------------------------------------------
-- Main Script
-----------------------------------------------------
-- Start debugging output if debugMod is enabled
if debugMode then
	set debugResponse to display dialog "Debug mode enabled. Press OK to start execution or Cancel to abort." buttons {"Cancel", "OK"} default button "OK" with icon caution
	
	if button returned of debugResponse is "Cancel" then
		-- User canceled execution
		return -- Exit the script
	end if
	
	debugOutput("NDI Receiver Management Script starting...")
end if


-- Find jq path dynamically
debugOutput("Determining path to jq and verifying installation.")
set jqPath to findJQPath()
if jqPath is "" then
	display dialog "Could not find jq. Please install jq and try again." & return & return & "You can install jq with Homebrew:" & return & "brew install jq" buttons {"OK"} default button "OK" with icon stop
	return -- Exit the script
end if
debugOutput("Found jq installation at: " & jqPath)


-- Load configuration from file
set config to loadConfiguration(jqPath)
if not config's success then
	return -- Exit if config can't be loaded
end if


-- Extract configuration values
set userName to config's userName
set userPW to config's userPW
set receiverList to config's receiverList
set connectTimeout to config's connectTimeout
set retryAttempts to config's retryAttempts
my debugOutput("Count of receivers to process: " & (count of receiverList))
my debugOutput("Retry attempts configured: " & retryAttempts)


-- At the beginning of the script, after loading configuration, display warning to user prior to proceeding
display dialog "About to set channels for " & (count of receiverList) & " NDI receivers." & return & return & "This will take a few moments during which there will be no progress indication on the screen." & return & return & "Please be patient. A summary will be displayed when complete." buttons {"OK", "Cancel"} default button "OK"
if button returned of result is "Cancel" then
	return -- Exit if user cancels
end if


-- Record start time in seconds
set startTimeSeconds to do shell script "date +%s"


-- This list will accumulate summary records for each receiver
set summaryResults to {}


-- Main multi-pass processing loop
set summaryResults to {}
set remainingReceiverIPs to receiverList
set processedReceivers to {}
set currentPass to 1
set maxPasses to retryAttempts + 1

my debugOutput("Beginning processing with up to " & maxPasses & " passes (" & retryAttempts & " retry attempts)")

-- Initialize a tracking record for each receiver
repeat with receiverIP in receiverList
	set theTracking to {theIP:receiverIP, theResult:missing value, passNum:0, required_retry:false}
	set end of processedReceivers to theTracking
end repeat

-- Continue processing passes until we've either processed all receivers successfully,
-- or we've reached the maximum number of retry attempts
repeat while ((count of remainingReceiverIPs) > 0) and (currentPass ≤ maxPasses)
	my debugOutput("Starting pass " & currentPass & " with " & (count of remainingReceiverIPs) & " receivers")
	
	-- Display progress info for this pass
	if currentPass > 1 then
		set passDisplay to "Retry pass " & (currentPass - 1) & " of " & retryAttempts
	else
		set passDisplay to "Initial processing"
	end if
	
	-- Process receivers in this pass
	set stillFailedReceivers to {}
	
	repeat with i from 1 to count of remainingReceiverIPs
		set receiverIP to item i of remainingReceiverIPs
		
		-- Update progress text
		set progressText to passDisplay & ": Processing receiver " & i & " of " & (count of remainingReceiverIPs) & ": " & receiverIP
		my debugOutput(progressText)
		
		-- Process the receiver using our modular function
		set receiverResult to processReceiver(receiverIP, userName, userPW, connectTimeout, jqPath)
		
		-- Update our tracking for this receiver
		repeat with j from 1 to count of processedReceivers
			set currentTracking to item j of processedReceivers
			
			if theIP of currentTracking is receiverIP then
				set theResult of item j of processedReceivers to receiverResult
				set passNum of item j of processedReceivers to currentPass
				
				if currentPass > 1 then
					set required_retry of item j of processedReceivers to true
				end if
				
				exit repeat
			end if
		end repeat
		
		-- Check if we need to retry this receiver in the next pass
		if receiverResult's status starts with "Success" then
			-- Success! No need to add to stillFailedReceivers
		else
			-- Failed - add to still failed list for next pass if we have more passes left
			if currentPass < maxPasses then
				set end of stillFailedReceivers to receiverIP
			end if
		end if
	end repeat
	
	-- Update for next pass
	set remainingReceiverIPs to stillFailedReceivers
	set currentPass to currentPass + 1
	
	-- If we need another pass, add a small delay to give devices time to recover
	if (count of remainingReceiverIPs) > 0 and currentPass ≤ maxPasses then
		my debugOutput("Waiting 2 seconds before retry pass " & (currentPass - 1) & "...")
		delay 2 -- Wait 2 seconds between passes
	end if
end repeat

-- Build the final results list from our tracking
repeat with receiverTracking in processedReceivers
	set end of summaryResults to theResult of receiverTracking
end repeat

-- Calculate how many passes we actually did
set passesCompleted to currentPass - 1
if passesCompleted > 1 then
	if passesCompleted > 2 then
		set retryInfo to "Completed " & passesCompleted & " passes (original + " & (passesCompleted - 1) & " retry passes)"
	else
		set retryInfo to "Completed " & passesCompleted & " passes (original + " & (passesCompleted - 1) & " retry pass)"
	end if
else
	set retryInfo to "Completed in a single pass (no retries needed)"
end if
my debugOutput(retryInfo)


-- Calculate elapsed time
set endTimeSeconds to do shell script "date +%s"
set elapsedSeconds to (endTimeSeconds as number) - (startTimeSeconds as number)
set elapsedFormatted to my formatSeconds(elapsedSeconds)


-- Analyze the overall status
set totalReceivers to count of summaryResults
set successCount to 0
set failCount to 0

repeat with i from 1 to count of summaryResults
	set currentResult to item i of summaryResults
	try
		set currentStatus to status of currentResult
		
		if currentStatus starts with "Success" then
			set successCount to successCount + 1
		else
			set failCount to failCount + 1
		end if
	on error
		-- If we can't access the status, count it as a failure
		set failCount to failCount + 1
		my debugOutput("Error accessing status for result " & i)
	end try
end repeat

-- Determine the appropriate icon based on success/failure ratio
set dialogIcon to missing value
set statusSummary to ""

if successCount = totalReceivers then
	-- All receivers succeeded
	set dialogIcon to note
	set statusSummary to "✅ All receivers configured successfully."
else if successCount > 0 then
	-- Some receivers succeeded
	set dialogIcon to caution
	set statusSummary to "⚠️ " & successCount & " of " & totalReceivers & " receivers configured successfully."
else
	-- No receivers succeeded
	set dialogIcon to stop
	set statusSummary to "❌ Failed to configure any receivers."
end if

-- Build and Display the Summary Dialog
set summaryText to "NDI Receiver Summary:" & return & return
set summaryText to summaryText & statusSummary & return & return
set summaryText to summaryText & retryInfo & return & return
set summaryText to summaryText & "Total time: " & elapsedFormatted & return & return

-- Display detailed results
repeat with i from 1 to count of summaryResults
	set currentResult to item i of summaryResults
	
	try
		set currentReceiver to receiver of currentResult
		set currentStatus to status of currentResult
		set currentSource to source of currentResult
		
		set summaryText to summaryText & "Receiver: " & currentReceiver & return
		
		-- Find if this receiver required a retry
		set requiredRetry to false
		repeat with j from 1 to count of processedReceivers
			set receiverTracking to item j of processedReceivers
			if theIP of receiverTracking is currentReceiver and required_retry of receiverTracking then
				set requiredRetry to true
				exit repeat
			end if
		end repeat
		
		-- Add a symbol to each receiver status
		if currentStatus starts with "Success" then
			if requiredRetry then
				-- Success after retry - show caution symbol
				set summaryText to summaryText & "Status: ⚠️ " & currentStatus & " (after retry)" & return
			else
				-- Success on first try
				set summaryText to summaryText & "Status: ✅ " & currentStatus & return
			end if
		else if currentStatus starts with "Unreachable" or currentStatus starts with "API" then
			set summaryText to summaryText & "Status: ❌ " & currentStatus & return
		else
			set summaryText to summaryText & "Status: ⚠️ " & currentStatus & return
		end if
		
		set summaryText to summaryText & "Source set: " & currentSource & return & return
	on error errMsg
		-- Handle errors in accessing result properties
		set summaryText to summaryText & "Receiver #" & i & ": [Error displaying result]" & return & return
		my debugOutput("Error in summary for result " & i & ": " & errMsg)
	end try
end repeat

-- Display the dialog with the appropriate icon
my debugOutput("Displaying summary dialog")
display dialog summaryText buttons {"OK"} default button "OK" with title "NDI Receiver Setup Results" with icon dialogIcon


-----------------------------------------------------
-- Utility Functions
-----------------------------------------------------
-- Find jq executable path
on findJQPath()
	set possiblePaths to {"/usr/local/bin/jq", "/usr/bin/jq", "/opt/homebrew/bin/jq", "~/bin/jq"}
	
	-- First try the which command to find it in PATH
	try
		set jqPathFromEnv to do shell script "which jq"
		if jqPathFromEnv is not "" then
			-- Found jq in PATH
			debugOutput("Found jq in PATH: " & jqPathFromEnv)
			return jqPathFromEnv
		end if
	on error
		-- which command failed, jq might not be in PATH
	end try
	
	-- Check each possible location
	repeat with testPath in possiblePaths
		try
			-- Expand path if it contains tilde
			if testPath begins with "~/" then
				set homeFolder to POSIX path of (path to home folder)
				set testPath to homeFolder & text 3 thru -1 of testPath
			end if
			
			-- Test if jq exists at this path
			do shell script "[ -x " & quoted form of testPath & " ]"
			debugOutput("Found jq installation at: " & testPath)
			return testPath
		on error
			-- Not found at this path, continue checking
		end try
	end repeat
	
	-- Not found in any location
	return ""
end findJQPath


-- Load configuration from file with flexible location detection
on loadConfiguration(jqPath)
	debugOutput("Loading NDI Receiver configuration JSON file.")
	set configResult to {success:false, userName:"", userPW:"", receiverList:{}, connectTimeout:4, retryAttempts:2}
	set configPath to missing value
	
	-- Determine if QLab is running, and if a workspace is open
	my debugOutput("Checking if QLab is running.")
	set runningInQLab to false
	
	try
		-- Check for QLab in a more resilient way
		set checkCmd to "ps -A | grep -v grep | grep -c \"QLab$\" || echo 0"
		set appCountStr to do shell script checkCmd
		
		-- Convert to number safely
		set appCount to 0
		try
			set appCount to appCountStr as number
		on error
			set appCount to 0
		end try
		
		if appCount > 0 then
			my debugOutput("QLab is running (detected " & appCount & " instance(s)).")
			-- Now it's safe to communicate with QLab
			try
				tell application "QLab"
					if exists front workspace then
						set runningInQLab to true
						my debugOutput("QLab has an open workspace. Looking for config file there.")
					else
						my debugOutput("QLab is running but no workspace is open.")
					end if
				end tell
			on error qlabErr
				my debugOutput("Error checking QLab workspace: " & qlabErr)
			end try
		else
			my debugOutput("QLab is not running. Will not check for QLab workspace.")
		end if
	on error checkErr
		my debugOutput("Error in process check: " & checkErr)
		set runningInQLab to false
	end try
	
	my debugOutput("Running in QLab context: " & runningInQLab)
	
	-- Try to find config based on context (QLab or standalone)
	if runningInQLab then
		-- In QLab: Look for config file relative to the current workspace
		try
			-- Using temporary variables outside of tell block
			set foundConfig to false
			set tempPath to ""
			
			tell application "QLab"
				if exists front workspace then
					set qLabPath to path of front workspace
					set tempPath to qLabPath
				end if
			end tell
			
			-- Process the path outside the tell block
			if tempPath is not "" then
				my debugOutput("QLab workspace path: " & tempPath)
				-- Extract directory from the full path
				set showfileFolder to do shell script "dirname " & quoted form of tempPath
				set defaultConfigPath to showfileFolder & "/" & configFileName
				my debugOutput("Looking for config at: " & defaultConfigPath)
				
				-- Check if config exists in the showfile's directory
				set fileExists to false
				tell application "System Events"
					if exists file defaultConfigPath then
						set fileExists to true
					end if
				end tell
				
				if fileExists then
					set configPath to defaultConfigPath
					my debugOutput("Found config file in QLab workspace folder: " & configPath)
				else
					my debugOutput("Config file not found in QLab workspace folder")
				end if
			else
				my debugOutput("No front workspace in QLab")
			end if
		on error qlabErr
			my debugOutput("Error checking QLab workspace location: " & qlabErr)
		end try
	else
		-- Standalone: Look for config in the script's directory
		try
			set scriptPath to path to me
			my debugOutput("Script path: " & scriptPath)
			
			-- Get the container in a more robust way
			set scriptFolder to ""
			try
				-- Extract the path up to the last colon
				set scriptPathText to scriptPath as text
				set lastColonOffset to offset of ":" in (reverse of characters of scriptPathText) as text
				if lastColonOffset > 0 then
					set scriptFolder to text 1 thru -((lastColonOffset) + 1) of scriptPathText
					my debugOutput("Script folder: " & scriptFolder)
				else
					-- Fallback method
					tell application "System Events"
						set scriptFolder to POSIX path of (container of scriptPath as alias)
						set scriptFolder to "Macintosh HD:" & text 2 thru end of scriptFolder
						my debugOutput("Script folder (fallback method): " & scriptFolder)
					end tell
				end if
			on error containerErr
				my debugOutput("Error getting script container: " & containerErr)
				-- Second fallback - use dirname
				try
					set scriptPathPOSIX to POSIX path of scriptPath
					set scriptFolder to do shell script "dirname " & quoted form of scriptPathPOSIX
					set scriptFolder to "Macintosh HD" & scriptFolder
					my debugOutput("Script folder (dirname method): " & scriptFolder)
				on error dirnameErr
					my debugOutput("Error getting script folder with dirname: " & dirnameErr)
					set scriptFolder to ""
				end try
			end try
			
			if scriptFolder is not "" then
				set defaultConfigPath to scriptFolder & ":" & configFileName
				my debugOutput("Looking for config at: " & defaultConfigPath)
				
				set fileExists to false
				try
					tell application "System Events"
						if exists file defaultConfigPath then
							set fileExists to true
						end if
					end tell
					
					if fileExists then
						set configPath to defaultConfigPath
						my debugOutput("Found config file in script folder: " & configPath)
					else
						my debugOutput("Config file not found in script folder")
					end if
				on error existsErr
					my debugOutput("Error checking if file exists: " & existsErr)
				end try
			else
				my debugOutput("Could not determine script folder")
			end if
		on error scriptErr
			my debugOutput("Error checking script location: " & scriptErr)
		end try
	end if
	
	-- If still not found, try Documents folder as a fallback
	if configPath is missing value then
		set docsConfigPath to (path to documents folder as text) & configFileName
		my debugOutput("Looking for config in Documents folder: " & docsConfigPath)
		
		set fileExists to false
		tell application "System Events"
			if exists file docsConfigPath then
				set fileExists to true
			end if
		end tell
		
		if fileExists then
			set configPath to docsConfigPath
			my debugOutput("Found config file in Documents folder: " & configPath)
		else
			my debugOutput("Config file not found in Documents folder")
		end if
	end if
	
	-- If still not found, prompt user to select it
	if configPath is missing value then
		my debugOutput("Config file not found in any standard location, prompting user")
		try
			set userPrompt to "Configuration file (" & configFileName & ") not found." & return & return & "Please select the configuration file:"
			set defaultLocation to path to documents folder
			set selectedFile to choose file with prompt userPrompt default location defaultLocation
			set configPath to selectedFile as text
			my debugOutput("User selected config file: " & configPath)
		on error selectErr
			my debugOutput("User canceled file selection or error occurred: " & selectErr)
			display dialog "No configuration file selected. Cannot continue." buttons {"OK"} default button "OK" with icon stop
			return configResult
		end try
	end if
	
	-- Now validate and parse the JSON file
	my debugOutput("Attempting to read config file: " & configPath)
	try
		set configFile to open for access configPath
		set configData to read configFile
		close access configFile
		my debugOutput("Successfully read config file, validating JSON structure.")
		
		-- Validate JSON structure before extracting fields
		try
			set jqCmd to "echo " & quoted form of configData & " | " & jqPath & " ."
			my debugOutput("Validating JSON structure.")
			do shell script jqCmd
			my debugOutput("JSON structure validation successful")
		on error jqError
			my debugOutput("JSON validation error: " & jqError)
			display dialog "The configuration file contains invalid JSON:" & return & return & jqError buttons {"OK"} default button "OK" with icon stop
			return configResult
		end try
		
		-- Extract individual fields with error handling for each
		try
			set jqCmd to "echo " & quoted form of configData & " | " & jqPath & " -r '.userName'"
			my debugOutput("Extracting userName.")
			set configResult's userName to do shell script jqCmd
			my debugOutput("Extracted userName: " & configResult's userName)
			
			if configResult's userName is "" or configResult's userName is "null" then
				my debugOutput("ERROR: userName is missing or empty.")
				error "userName is missing or empty"
			end if
		on error fieldErr
			my debugOutput("ERROR extracting userName: " & fieldErr)
			display dialog "Error in configuration file: userName field is invalid or missing." buttons {"OK"} default button "OK" with icon stop
			return configResult
		end try
		
		try
			set jqCmd to "echo " & quoted form of configData & " | " & jqPath & " -r '.userPW'"
			my debugOutput("Extracting userPW.")
			set configResult's userPW to do shell script jqCmd
			my debugOutput("Extracted userPW: " & configResult's userPW)
			
			if configResult's userPW is "" or configResult's userPW is "null" then
				my debugOutput("ERROR: userPW is missing or empty")
				error "userPW is missing or empty"
			end if
		on error fieldErr
			my debugOutput("ERROR extracting userPW: " & fieldErr)
			display dialog "Error in configuration file: userPW field is invalid or missing." buttons {"OK"} default button "OK" with icon stop
			return configResult
		end try
		
		try
			-- Verify receiverList exists and is an array
			set jqCmd to "echo " & quoted form of configData & " | " & jqPath & " '.receiverList | type'"
			my debugOutput("Checking receiverList type.")
			set receiverListType to do shell script jqCmd
			my debugOutput("receiverList type: " & receiverListType)
			
			if receiverListType does not contain "array" then
				my debugOutput("ERROR: receiverList must be an array, found type: " & receiverListType)
				display dialog "Error in configuration file: receiverList must be an array." buttons {"OK"} default button "OK" with icon stop
				return configResult
			end if
			
			set jqCmd to "echo " & quoted form of configData & " | " & jqPath & " -r '.receiverList[]'"
			my debugOutput("Extracting receiverList.")
			set configResult's receiverList to paragraphs of (do shell script jqCmd)
			my debugOutput("Extracted " & (count of configResult's receiverList) & " receivers: " & (configResult's receiverList as text))
			
			if (count of configResult's receiverList) is 0 or configResult's receiverList is {"null"} then
				my debugOutput("ERROR: receiverList is empty")
				display dialog "Error in configuration file: receiverList is empty." buttons {"OK"} default button "OK" with icon stop
				return configResult
			end if
		on error fieldErr
			my debugOutput("ERROR extracting receiverList: " & fieldErr)
			display dialog "Error in configuration file: receiverList field is invalid or missing." & return & return & fieldErr buttons {"OK"} default button "OK" with icon stop
			return configResult
		end try
		
		-- First check if the connectTimeout field exists at all
		set jqCmd to "echo " & quoted form of configData & " | " & jqPath & " -r 'has(\"connectTimeout\")'"
		my debugOutput("Checking if connectTimeout exists.")
		set hasTimeout to do shell script jqCmd
		my debugOutput("connectTimeout exists: " & hasTimeout)
		
		if hasTimeout is "true" then
			-- Field exists, get its value and check its type
			set jqCmd to "echo " & quoted form of configData & " | " & jqPath & " -r '.connectTimeout | type'"
			my debugOutput("Checking connectTimeout type.")
			set timeoutType to do shell script jqCmd
			my debugOutput("connectTimeout type: " & timeoutType)
			
			if timeoutType contains "number" then
				-- It's a number, use it directly
				set jqCmd to "echo " & quoted form of configData & " | " & jqPath & " -r '.connectTimeout'"
				my debugOutput("Extracting connectTimeout (number).")
				set timeoutValue to do shell script jqCmd
				set configResult's connectTimeout to timeoutValue as number
				my debugOutput("Set connectTimeout to: " & configResult's connectTimeout)
			else if timeoutType contains "string" then
				-- It's a string, try to convert to number
				set jqCmd to "echo " & quoted form of configData & " | " & jqPath & " -r '.connectTimeout'"
				my debugOutput("Extracting connectTimeout (string).")
				set timeoutStr to do shell script jqCmd
				my debugOutput("Got connectTimeout string: " & timeoutStr)
				try
					set configResult's connectTimeout to timeoutStr as number
					my debugOutput("Converted connectTimeout to number: " & configResult's connectTimeout)
				on error
					my debugOutput("ERROR: connectTimeout string could not be converted to number: " & timeoutStr)
					display dialog "Error in configuration file: connectTimeout must be a number, got \"" & timeoutStr & "\"" buttons {"OK"} default button "OK" with icon stop
					return configResult
				end try
			else if timeoutType contains "null" then
				-- It's explicitly null, use default
				set configResult's connectTimeout to 4
				my debugOutput("connectTimeout is null, using default: 4")
			else
				-- It's some other type (boolean, object, array)
				my debugOutput("ERROR: connectTimeout has invalid type: " & timeoutType)
				display dialog "Error in configuration file: connectTimeout must be a number, got " & timeoutType buttons {"OK"} default button "OK" with icon stop
				return configResult
			end if
		else
			-- Field doesn't exist at all, use default
			set configResult's connectTimeout to 4
			my debugOutput("connectTimeout not found in config, using default: 4")
		end if
		
		-- Check for retryAttempts in config
		set configResult's retryAttempts to 2 -- Default value
		try
			set hasRetryAttempts to do shell script "echo " & quoted form of configData & " | " & jqPath & " -r 'has(\"retryAttempts\")'"
			my debugOutput("Checking if retryAttempts exists: " & hasRetryAttempts)
			
			if hasRetryAttempts is "true" then
				set retryType to do shell script "echo " & quoted form of configData & " | " & jqPath & " -r '.retryAttempts | type'"
				my debugOutput("retryAttempts type: " & retryType)
				
				if retryType contains "number" then
					set retryValue to do shell script "echo " & quoted form of configData & " | " & jqPath & " -r '.retryAttempts'"
					set configResult's retryAttempts to retryValue as number
					my debugOutput("Using retryAttempts from config: " & configResult's retryAttempts)
				else
					my debugOutput("retryAttempts is not a number, using default: " & configResult's retryAttempts)
				end if
			else
				my debugOutput("retryAttempts not found in config, using default: " & configResult's retryAttempts)
			end if
		on error retryErr
			my debugOutput("Error parsing retryAttempts: " & retryErr & ", using default: " & configResult's retryAttempts)
		end try
		
		set configResult's success to true
		my debugOutput("Configuration loaded successfully from: " & configPath)
		return configResult
	on error errMsg
		my debugOutput("Failed to load configuration: " & errMsg)
		display dialog "Failed to load configuration: " & errMsg buttons {"OK"} default button "OK" with icon stop
		return configResult
	end try
end loadConfiguration


-- Check receiver availability (both network and API)
on checkReceiverAvailability(receiverIP, jqPath)
	-- Initialize all local variables at the start
	set pingSuccess to false
	set apiSuccess to false
	set errorMessage to ""
	
	-- Debug timestamp before network check
	debugOutput("Starting network ping check for " & receiverIP)
	
	-- Stage 1: Check basic network connectivity with strict timeout
	try
		-- Use a very short timeout to avoid hanging - with debugging output
		set pingCmd to "ping -c 1 -W 0.5 -t 1 " & receiverIP & " 2>&1 || echo 'Ping timeout'"
		debugOutput("Running ping command: " & pingCmd)
		
		set pingResponse to do shell script pingCmd
		
		-- Log raw response for debugging
		debugOutput("Raw ping response for " & receiverIP & ": " & pingResponse)
		
		if pingResponse contains "1 packets transmitted, 1 packets received" then
			set pingSuccess to true
			debugOutput("Network ping successful for " & receiverIP)
		else
			set errorMessage to "Network ping failed: " & pingResponse
			debugOutput("Network ping failed for " & receiverIP & ": " & pingResponse)
			-- Return early with just ping results
			return {reachable:pingSuccess, apiAvailable:apiSuccess, message:errorMessage}
		end if
	on error pingErr
		set errorMessage to "Network error: " & pingErr
		debugOutput("Network ping error for " & receiverIP & ": " & pingErr)
		-- Return early with just ping results
		return {reachable:pingSuccess, apiAvailable:apiSuccess, message:errorMessage}
	end try
	
	-- Only proceed to API check if ping was successful
	if not pingSuccess then
		return {reachable:pingSuccess, apiAvailable:apiSuccess, message:errorMessage}
	end if
	
	-- Debug timestamp before API check
	debugOutput("Starting API ping check for " & receiverIP)
	
	-- Stage 2: Check API availability with strict timeout
	try
		set apiPingURL to "http://" & receiverIP & "/mwapi?method=ping"
		-- Force a very short timeout to avoid hanging
		set curlCmd to "curl --max-time 2 --connect-timeout 1 --silent " & quoted form of apiPingURL & " || echo '{\"status\":\"timeout\"}'"
		
		debugOutput("Running curl command: " & curlCmd)
		
		set apiResponse to do shell script curlCmd
		
		-- Log raw response for debugging
		debugOutput("Raw API response for " & receiverIP & ": " & apiResponse)
		
		-- Verify it's a valid response
		set isValidResponse to false
		try
			set jqCmd to "echo " & quoted form of apiResponse & " | " & jqPath & " '.status' 2>/dev/null || echo 'parse_error'"
			debugOutput("Running jq command: " & jqCmd)
			
			set statusCheck to do shell script jqCmd
			debugOutput("Status check result: " & statusCheck)
			
			if statusCheck as text is "0" then
				set isValidResponse to true
			end if
		end try
		
		if isValidResponse then
			set apiSuccess to true
			set errorMessage to "Receiver available"
			debugOutput("API ping successful for " & receiverIP)
		else
			set errorMessage to "API ping failed: Invalid response - " & apiResponse
			debugOutput("API ping failed for " & receiverIP & ": Invalid response - " & apiResponse)
		end if
	on error apiErr
		set errorMessage to "API error: " & apiErr
		debugOutput("API ping error for " & receiverIP & ": " & apiErr)
	end try
	
	debugOutput("Completed availability check for " & receiverIP)
	
	-- Create and return final result record
	return {reachable:pingSuccess, apiAvailable:apiSuccess, message:errorMessage}
end checkReceiverAvailability


-- Login to receiver and capture session cookie
on loginToReceiver(receiverIP, userName, userPW, connectTimeout)
	set loginURL to "http://" & receiverIP & "/mwapi?method=login&id=" & userName & "&pass=" & userPW
	
	-- Get the login response with headers
	set loginCmd to "curl -i --connect-timeout " & connectTimeout & " --max-time " & (connectTimeout * 2) & " --silent " & quoted form of loginURL
	debugOutput("Login command: " & loginCmd)
	set fullLoginResponse to do shell script loginCmd
	
	-- Log the complete response for debugging
	debugOutput("Full login response: " & fullLoginResponse)
	
	-- Extract the session ID from the Set-Cookie header
	try
		set cookieCmd to "echo " & quoted form of fullLoginResponse & " | grep -i 'Set-Cookie:' | awk -F'[=;]' '{print $2}'"
		set sessionID to do shell script cookieCmd
		debugOutput("Extracted session ID: " & sessionID)
		
		-- Store the cookie in the correct format
		if sessionID is not "" then
			set sessionCookie to "sid=" & sessionID
			debugOutput("Set cookie to: " & sessionCookie)
			-- Return success response since we got a session ID
			return "{\"status\": 0}"
		else
			set sessionCookie to ""
			debugOutput("No session ID found in response.")
			-- Return error if no session ID found
			return "{\"status\": -1, \"error\": \"No session ID in response\"}"
		end if
	on error cookieErr
		set sessionCookie to ""
		debugOutput("Error extracting cookie: " & cookieErr)
		-- Return error for extraction failure
		return "{\"status\": -1, \"error\": \"Failed to extract cookie: " & cookieErr & "\"}"
	end try
end loginToReceiver


-- Process a single receiver and return the result
on processReceiver(receiverIP, userName, userPW, connectTimeout, jqPath)
	my debugOutput("Starting to process receiver: " & receiverIP)
	
	-- Initialize a result record
	set receiverResult to {receiver:receiverIP, status:"", source:""}
	
	-- Reset session cookie for each new receiver
	set sessionCookie to ""
	
	try
		-- (A) Check if receiver is available (both network and API)
		my debugOutput("STEP A: Checking receiver availability for " & receiverIP)
		set availabilityStatus to checkReceiverAvailability(receiverIP, jqPath)
		
		if not availabilityStatus's reachable then
			set receiverResult's status to "Unreachable (network ping failed)"
			set receiverResult's source to "N/A"
			my debugOutput("Network unreachable for " & receiverIP & ": " & availabilityStatus's message)
			error "Skipping receiver " & receiverIP & " - network unreachable"
		else if not availabilityStatus's apiAvailable then
			set receiverResult's status to "API unavailable"
			set receiverResult's source to "N/A"
			my debugOutput("API unavailable for " & receiverIP & ": " & availabilityStatus's message)
			error "Skipping receiver " & receiverIP & " - API unavailable"
		end if
		
		-- (B) Login to the receiver using the new session cookie management
		my debugOutput("STEP B: Logging in to " & receiverIP)
		set loginResponse to loginToReceiver(receiverIP, userName, userPW, connectTimeout)
		my debugOutput("Login Response for " & receiverIP & ": " & loginResponse)
		my checkResponse(loginResponse, "Login failed for receiver " & receiverIP, jqPath)
		
		-- (C) Retrieve the list of available sources using session cookie
		my debugOutput("STEP C: Retrieving sources from " & receiverIP)
		set getSourcesURL to "http://" & receiverIP & "/mwapi?method=get-ndi-sources"
		set jsonResponse to runCURLWithSession(getSourcesURL, connectTimeout)
		my debugOutput("JSON Response for " & receiverIP & ": " & jsonResponse)
		my checkResponse(jsonResponse, "Failed to retrieve sources for receiver " & receiverIP, jqPath)
		
		-- (D) Find matching source for this receiver
		my debugOutput("STEP D: Finding matching source for " & receiverIP)
		set sourceResult to findMatchingSource(jsonResponse, receiverIP, jqPath)
		
		if sourceResult's found then
			-- (E) Set the receiver's channel to the found source
			my debugOutput("STEP E: Setting channel for " & receiverIP)
			set setChannelURL to "http://" & receiverIP & "/mwapi?method=set-channel&ndi-name=true&name=" & sourceResult's encodedName
			set setChannelResponse to runCURLWithSession(setChannelURL, connectTimeout)
			my debugOutput("Set Channel Response for " & receiverIP & ": " & setChannelResponse)
			my checkResponse(setChannelResponse, "Set channel for receiver " & receiverIP, jqPath)
			
			set receiverResult's status to "Success"
			set receiverResult's source to sourceResult's sourceName
		else
			set receiverResult's status to "Fail (No valid source found)"
			set receiverResult's source to "N/A"
		end if
		
		-- (F) Logout from the receiver
		my debugOutput("STEP F: Logging out from " & receiverIP)
		set logoutURL to "http://" & receiverIP & "/mwapi?method=logout"
		runCURLWithSession(logoutURL, connectTimeout)
		
	on error errMsg
		my debugOutput("ERROR processing receiver " & receiverIP & ": " & errMsg)
	end try
	
	my debugOutput("Finished processing receiver: " & receiverIP)
	return receiverResult
end processReceiver


-- Find a matching NDI source for the given receiver
on findMatchingSource(jsonResponse, receiverIP, jqPath)
	-- Create the result record with default values
	set sourceResult to {found:false, sourceName:"", encodedName:""}
	
	-- Use jq to filter sources for the desired receiver IP
	set jqQuery to ".sources[] | select(.\"ndi-name\" | contains(\"" & receiverIP & "\"))"
	set targetSourceRaw to do shell script "echo " & quoted form of jsonResponse & " | " & jqPath & " '" & jqQuery & "'"
	my debugOutput("jq target source for " & receiverIP & ": " & targetSourceRaw)
	
	if targetSourceRaw is not "" then
		-- Extract the ndi-name field using jq and remove extra quotes
		set ndiNameRaw to do shell script "echo " & quoted form of targetSourceRaw & " | " & jqPath & " '.\"ndi-name\"' | tr -d '\"'"
		my debugOutput("NDI Name for " & receiverIP & ": " & ndiNameRaw)
		set encodedNdiName to urlEncode(ndiNameRaw)
		my debugOutput("Encoded NDI Name for " & receiverIP & ": " & encodedNdiName)
		
		-- Set result values
		set sourceResult's found to true
		set sourceResult's sourceName to ndiNameRaw
		set sourceResult's encodedName to encodedNdiName
	end if
	
	return sourceResult
end findMatchingSource


-- Run curl command with session cookie
on runCURLWithSession(theURL, connectTimeout)
	if sessionCookie is "" then
		-- No cookie available, just run a simple curl command
		set curlCmd to "curl --connect-timeout " & connectTimeout & " --max-time " & (connectTimeout * 2) & " --silent " & quoted form of theURL
		debugOutput("Running curl command (no cookie): " & curlCmd)
		return do shell script curlCmd
	else
		-- Use the stored session cookie in the format "sid=SESSIONID"
		set curlCmd to "curl --connect-timeout " & connectTimeout & " --max-time " & (connectTimeout * 2) & " --silent -b " & quoted form of sessionCookie & " " & quoted form of theURL
		debugOutput("Running curl command (with cookie): " & curlCmd)
		return do shell script curlCmd
	end if
end runCURLWithSession


-- URL Encode function
on urlEncode(input)
	debugOutput("URL encoding input: " & input)
	try
		set encoded to do shell script "python3 -c 'import urllib.parse; print(urllib.parse.quote(\"" & input & "\"))'"
		debugOutput("URL encoded result: " & encoded)
		return encoded
	on error errMsg
		debugOutput("URL Encoding failed: " & errMsg)
		error "URL Encoding failed: " & errMsg
	end try
end urlEncode


-- Check API response
on checkResponse(response, errorMessage, jqPath)
	debugOutput("Checking API response: " & response)
	try
		set jqCmd to "echo " & quoted form of response & " | " & jqPath & " '.status'"
		debugOutput("Running status check: " & jqCmd)
		
		set statusValue to do shell script jqCmd
		debugOutput("Status check result: " & statusValue)
		
		if statusValue as text is not "0" then
			debugOutput("API check FAILED: " & errorMessage)
			error errorMessage & " failed. Response: " & response
		else
			debugOutput("API check SUCCESS")
		end if
	on error errMsg
		debugOutput("API check ERROR: " & errMsg)
		error errorMessage & " (jq parse error: " & errMsg & "). Full Response: " & response
	end try
end checkResponse


-- Format seconds into minutes and seconds
on formatSeconds(totalSeconds)
	set minutes to totalSeconds div 60
	set remainingSeconds to totalSeconds mod 60
	if minutes > 0 then
		return minutes & " min " & remainingSeconds & " sec"
	else
		return totalSeconds & " seconds"
	end if
end formatSeconds


-- Enhanced debug output function
on debugOutput(msg)
	-- Only log if debug mode is enabled
	if debugMode then
		set currentDate to do shell script "date '+%Y-%m-%d %H:%M:%S.%N'"
		set logMsg to " [" & currentDate & "] " & msg & " "
		
		-- Log to the console
		log logMsg
	end if
end debugOutput
